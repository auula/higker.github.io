<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis那些事随笔</title>
    <link href="/2020/08/04/Redis%E9%82%A3%E4%BA%9B%E4%BA%8B%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/08/04/Redis%E9%82%A3%E4%BA%9B%E4%BA%8B%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghew9a67sqj30jg07bt8y.jpg" srcset="/img/loading.gif" alt=""></p><p><strong><code>Redis</code>（<code>Remote Dictionary Server</code>)，即<code>远程字典服务</code>，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<code>Key-Value数据库</code>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</strong></p><blockquote><p>随着时代的发展，现在用户对应用网络响应速度有较高的响应时间要求，而且数据和用户量很多，使用传统的方式很满足这些条件。服务器架构也在从单体应用变成多台服务器的分布式架构，从而出现了一些数据同步….一系列的问题，<code>redis</code>就是一个基于内存来存储数据的NOSQl数据库，它比传统的关系型数据库更强大速度很快。</p></blockquote><h3 id="关系型数据库理论-ACID"><a href="#关系型数据库理论-ACID" class="headerlink" title="关系型数据库理论 - ACID"></a>关系型数据库理论 - ACID</h3><p>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p><ul><li><strong>A – Atomicity – 原子性</strong></li></ul><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有被执行过一样。</p><ul><li><strong>C – Consistency – 一致性</strong><br>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>I – Isolation – 隔离性</strong><br>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>D – Durability – 持久性</strong><br>事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。</li></ul><p><strong>关系型数据库的优势：</strong></p><p>容易理解: 二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>保持数据的一致性（事务处理）<br>由于以标准化为前提，数据更新的开销很小（相同的字段基本上都只有一处）<br>支持SQL，可以进行Join等复杂查询（几张表之间）</p><p><strong>关系型数据库的不足：</strong></p><ul><li><p>不擅长的处理</p></li><li><p>大量数据的写入处理</p></li><li><p>为有数据更新的表做索引或表结构（schema）变更</p></li><li><p>字段不固定时应用</p></li><li><p>对简单查询需要快速返回结果的处理</p></li></ul><h3 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h3><p>结构不固定，集合内数据字段可以不一样，自由度高，可以减少一些时间和空间的开销。</p><p><strong>四大类型：</strong></p><ul><li>键值对存储（key-value）</li><li>文档存储（document store：mongodb）</li><li>基于列的数据库（column-oriented），还有就是图形数据库（graph database）</li></ul><p><strong>主流的非关系型数据库有 Redis、MongoDB、Cloudant</strong></p><p><strong>特征：</strong></p><ul><li>1、使用键值对存储数据；</li><li>2、分布式；</li><li>3、一般不支持ACID特性；</li><li>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</li></ul><p><strong>优点：</strong></p><ul><li>1、无需经过sql层的解析，读写性能很高；</li><li>2、基于键值对，数据没有耦合性，容易扩展；</li><li>3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。</li></ul><p><strong>缺点：</strong></p><ul><li>1、不提供sql支持，学习和使用成本较高；</li><li>2、无事务处理，附加功能bi和报表等支持也不好；</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>String: 字符串</li><li>Hash: 散列</li><li>List: 列表</li><li>Set: 集合</li><li>Sorted Set: 有序集合</li><li>还有新加的里地理位置等类型</li></ul><h3 id="特点和缺点"><a href="#特点和缺点" class="headerlink" title="特点和缺点"></a>特点和缺点</h3><ul><li>内存存储，读写操作快</li><li>效率高，可用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器，计数器（浏览量!）</li><li>流量限流，消息队列消峰</li><li><code>断电内存数据丢失（所有持久化很重要）</code></li><li><code>RDB，AOF 持久化策略</code></li></ul><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p><strong>1. Linux解决安装一些依赖问题</strong></p><pre><code class="bash">yum groups install Development Tools</code></pre><p><strong>2. 下载解压编译安装</strong></p><pre><code class="bash">$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz$ tar xzf redis-5.0.5.tar.gz$ cd redis-5.0.5$ make</code></pre><p>进入到解压后的 src 目录，通过如下命令启动Redis:</p><p><code>$ src/redis-server</code></p><p>您可以使用内置的客户端与Redis进行交互:</p><pre><code class="bash">$ src/redis-cliredis&gt; set foo barOKredis&gt; get foo&quot;bar&quot;</code></pre><p>ok大功告成。</p><h3 id="配置Redis-conf文件"><a href="#配置Redis-conf文件" class="headerlink" title="配置Redis.conf文件"></a>配置<code>Redis.conf</code>文件</h3><p><strong>常用的参数</strong><br><a href="https://www.runoob.com/redis/redis-conf.html" target="_blank" rel="noopener">点击查看常用的配置参数资料</a></p><h3 id="Redis基本测试redis-benchmark"><a href="#Redis基本测试redis-benchmark" class="headerlink" title="Redis基本测试redis-benchmark"></a><code>Redis</code>基本测试<code>redis-benchmark</code></h3><pre><code class="bash">1    -h    指定服务器主机名    127.0.0.12    -p    指定服务器端口    63793    -s    指定服务器 socket    4    -c    指定并发连接数    505    -n    指定请求数    100006    -d    以字节的形式指定 SET/GET 值的数据大小    27    -k    1=keep alive 0=reconnect    18    -r    SET/GET/INCR 使用随机 key, SADD 使用随机值    9    -P    通过管道传输 &lt;numreq&gt; 请求    110    -q    强制退出 redis。仅显示 query/sec 值    11    --csv    以 CSV 格式输出    12    -l    生成循环，永久执行测试    13    -t    仅运行以逗号分隔的测试命令列表。    14    -I    Idle 模式。仅打开 N 个 idle 连接并等待。    </code></pre><h3 id="性能测试实例"><a href="#性能测试实例" class="headerlink" title="性能测试实例"></a>性能测试实例</h3><p><strong>以下实例我们使用了多个参数来测试 redis 性能：</strong></p><pre><code class="bash">$ redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -qSET: 146198.83 requests per secondLPUSH: 145560.41 requests per second</code></pre><h3 id="常用的命令📓"><a href="#常用的命令📓" class="headerlink" title="常用的命令📓"></a>常用的命令📓</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>SELECT n</code></td><td>选择数据库</td></tr><tr><td><code>KEYS *</code></td><td>查看KEY列表</td></tr><tr><td><code>DEL KEY</code></td><td>删除指定KEY</td></tr><tr><td><code>TYPE KEY</code></td><td>查看KEY类型</td></tr><tr><td><code>EXISTS KEY</code></td><td>检查KEY是否存在</td></tr><tr><td><code>SET KEY VALUE</code></td><td>设置KEY和值</td></tr><tr><td><code>GET KEY</code></td><td>获取KEY的值</td></tr><tr><td><code>DBSIZE</code></td><td>查看DB大小</td></tr><tr><td><code>FLUSHDB</code></td><td>清空当前DB</td></tr><tr><td><code>FLUSHALL</code></td><td>清空所有DB</td></tr><tr><td><code>FLUSHALL</code></td><td>清空所有DB</td></tr><tr><td><code>EXPIRE KEY S</code></td><td>设置KEY多久到期/秒</td></tr><tr><td><code>INCR KEY</code></td><td>KEY值自加1</td></tr><tr><td><code>DECR KEY</code></td><td>KEY值自减1</td></tr><tr><td><code>INCRBY KEY 5</code></td><td>设置KEY值自增量</td></tr><tr><td><code>GETRANGE KEY 1 5</code></td><td>获取KEY指定区间的值</td></tr><tr><td><code>STRLEN KEY</code></td><td>获取KEY值长度</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈分布式消息队列</title>
    <link href="/2020/05/27/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2020/05/27/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="什么消息队列"><a href="#什么消息队列" class="headerlink" title="什么消息队列?"></a>什么消息队列?</h2><p><code>消息队列</code>这个词陌生人一听挖槽好牛逼啊好高大上啊，消息队列，一般我们会简称它为<code>MQ(Message Queue)</code>，嗯，就是很直白的简写。</p><ul><li>队列是一种先进先出的数据结构</li><li>消息队列<code>（MessageQueue）</code>是一种应用间的通信方式</li><li>消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象</li><li>消息发送者 可以发送一个消息而无须等待响应。消息发送者 将消息发送到一条 虚拟的通道（主题 或 队列）上，消息接收者 则 订阅 或是 监听 该通道。一条信息可能最终转发给 一个或多个 消息接收者，这些接收者都无需对 消息发送者 做出 同步回应。整个过程都是 异步的。</li></ul><blockquote><p>维基百科上是这么描述的: 在计算机科学中，消息队列是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。</p></blockquote><p><strong>我<code>SDing</code>个人总结就是: 消息队列是一个先进先出的数据存储容器，它可以帮助不同的程序之间进行数据的通讯。</strong></p><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><p>说到消息队列就要说到消息队列里面最常用的方式就是发布和订阅了。</p><blockquote><p>维基百科上是这么描述的: 在软件架构中，发布-订阅是一种消息范式，消息的发送者不会将消息直接发送给特定的接收者。而是将发布的消息分为不同的类别，无需了解哪些订阅者可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。 发布/订阅是消息队列范式的兄弟，通常是更大的面向消息中间件系统的一部分。 </p></blockquote><ul><li>消息生产者 （生产消息发送到消息队列里）</li><li>消息中间件 <code>(Kafka,Nsq,RabbitMQ)</code></li><li>消息消费者  (从消息队列里面拿取订阅的消息)</li></ul><p><strong>我的一句话总结就是: 消息发布和订阅就是一个架构方式，可以在不同的程序之间获取自己需要的数据，解耦模式。</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7dwe18p4j30hj07vaaq.jpg" srcset="/img/loading.gif" alt="消息队列"></p><p>可以看看这个倔金的文章:<a href="https://juejin.im/post/5cb025fb5188251b0351ef48" target="_blank" rel="noopener">消息队列解耦</a> or <a href="https://juejin.im/post/5b41fe36e51d45191252e79e" target="_blank" rel="noopener">消息队列详解</a></p><h2 id="常见中间件"><a href="#常见中间件" class="headerlink" title="常见中间件"></a>常见中间件</h2><ol><li>NSQ</li><li>Kafka</li><li>ZeroMQ</li><li>MetaMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>ActiveMQ</li><li>Redis (主要是缓存但是也可以实现消息队列)</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code-Server搭建</title>
    <link href="/2020/05/26/Code-Server%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/05/26/Code-Server%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5z665ly1j30dc06o74k.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>在我们开发调试程序的时候我们的一些程序部署在服务器上运行，但是很多配置文件，这样我们修改起来比较麻烦，使用我们可以通过vscode服务器版本进行开发。</p></blockquote><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>安装可以通过这个<code>https://github.com/cdr/code-server</code>仓库上面的文件来。</p><p><strong>根据自己对应的系统版本安装</strong></p><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian, Ubuntu"></a>Debian, Ubuntu</h3><pre><code class="shell">curl -sSOL https://github.com/cdr/code-server/releases/download/v3.3.1/code-server_3.3.1_amd64.debsudo dpkg -i code-server_3.3.1_amd64.debsystemctl --user enable --now code-server# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml</code></pre><h3 id="Fedora-Red-Hat-SUSE"><a href="#Fedora-Red-Hat-SUSE" class="headerlink" title="Fedora, Red Hat, SUSE"></a>Fedora, Red Hat, SUSE</h3><pre><code class="shell">curl -sSOL https://github.com/cdr/code-server/releases/download/v3.3.1/code-server-3.3.1-amd64.rpmsudo yum install -y code-server-3.3.1-amd64.rpmsystemctl --user enable --now code-server# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml</code></pre><h3 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h3><pre><code class="shell"># Installs code-server from the AUR using yay.yay -S code-serversystemctl --user enable --now code-server# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml# Installs code-server from the AUR with plain makepkg.git clone https://aur.archlinux.org/code-server.gitcd code-servermakepkg -sisystemctl --user enable --now code-server</code></pre><p>默认访问地址: <code>http://127.0.0.1:8080</code>. 默认密码配置:<code>~/.config/code-server/config.yaml</code></p><h3 id="Firewall-wall-setting-port"><a href="#Firewall-wall-setting-port" class="headerlink" title="Firewall wall setting port"></a>Firewall wall setting port</h3><p>  <code>–permanent</code> 添加这个参数防火墙永久生效. </p><p>  默认端口是 8080.</p><pre><code>$: firewall-cmd --zone=public --add-port=8080/tcp --permanent# 刷新配置$: firewall-cmd --reload</code></pre><h3 id="Edit-config-file"><a href="#Edit-config-file" class="headerlink" title="Edit config file"></a>Edit config file</h3><p>  使用 <code>vi</code> 打开配置文件<code>~/.config/code-server/config.yaml</code></p><pre><code>$: vi  ~/.config/code-server/config.yaml</code></pre><p>  使用键盘<code>i</code> 键进入insert模式</p><pre><code> bind-addr: 127.0.0.1:8080        auth: password password: 706039b9fa******b847cec0c cert: false ~ ~ -- INSERT --</code></pre><p>   <code>bind-addr</code> 修改为 <code>0.0.0.0:8080</code> (这样就可以远程访问)<br>   <code>password</code> 修改为你自定义密码</p><p>  按键盘上的<code>esc</code> 键输入<code>: wq</code> 保存退出文件</p><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><pre><code>$: /usr/bin/code-server</code></pre><p>output:</p><pre><code>[root@vultr ~]# /usr/bin/code-serverinfo  Wrote default config file to ~/.config/code-server/config.yamlinfo  Using config file ~/.config/code-server/config.yamlinfo  Using user-data-dir ~/.local/share/code-serverinfo  code-server 3.3.1 6f1309795e1cb930edba68cdc7c3dcaa01da0ab3info  HTTP server listening on http://127.0.0.1:8080info      - Using password from ~/.config/code-server/config.yamlinfo      - To disable use `--auth none`info    - Not serving HTTPS</code></pre><p><strong>不需要密码可以添加 <code>-auth none</code> 参数</strong></p><p> <strong>or  start by designated user</strong></p><pre><code>$:  systemctl --user enable --now code-server</code></pre><p> <strong>now visit <a href="http://your.server.address:8080" target="_blank" rel="noopener">http://your.server.address:8080</a>. Good luck~</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Azure上安装Kafka</title>
    <link href="/2020/05/25/Azure%E4%B8%8A%E5%AE%89%E8%A3%85Kafka/"/>
    <url>/2020/05/25/Azure%E4%B8%8A%E5%AE%89%E8%A3%85Kafka/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4liai3d3j30k008jt9d.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么是Kafka"><a href="#什么是Kafka" class="headerlink" title="什么是Kafka?"></a>什么是Kafka?</h2><p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。<br>对于像 Hadoop 一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka 的目的是通过 Hadoop 的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。<br>Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。<br>Kafka 最初是由领英开发，并随后于 2011 年初开源，并于 2012 年 10 月 23 日由 Apache Incubator 孵化出站。2014 年 11 月，几个曾在领英为 Kafka 工作的工程师，创建了名为 Confluent 的新公司，并着眼于 Kafka。根据 2014 年 Quora 的帖子，Jay Kreps 似乎已经将它以作家弗朗茨·卡夫卡命名。Kreps 选择将该系统以一个作家命名是因为，它是“一个用于优化写作的系统”，而且他很喜欢卡夫卡的作品。</p><p><strong>Kafka 存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka 运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</strong></p><p><strong>Kafka 高效地处理实时流式数据，可以实现与 Storm、HBase 和 Spark 的集成。作为聚类部署到多台服务器上，Kafka 处理它所有的发布和订阅消息系统使用了四个 API，即生产者 API、消费者 API、Stream API 和 Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如 JMS、AMQP 等。</strong></p><p><strong>Kafka 架构的主要术语包括 Topic、Record 和 Broker。Topic 由 Record 组成，Record 持有不同的信息，而 Broker 则负责复制消息。Kafka 有四个主要 API：</strong></p><ul><li>生产者 API：支持应用程序发布 Record 流。</li><li>消费者 API：支持应用程序订阅 Topic 和处理 Record 流。</li><li>Stream API：将输入流转换为输出流，并产生结果。</li><li>Connector API：执行可重用的生产者和消费者 API，可将 Topic 链接到现有应用程序。</li></ul><p><strong>相关术语</strong></p><ul><li>Topic 用来对消息进行分类，每个进入到 Kafka 的信息都会被放到一个 Topic 下</li><li>Broker 用来实现数据存储的主机服务器</li><li>Partition 每个 Topic 中的消息会被分为若干个 Partition，以提高消息的处理效率</li><li>Producer 消息的生产者</li><li>Consumer 消息的消费者</li><li>Consumer Group 消息的消费群组</li></ul><p>由于其广泛集成到企业级基础设施中，监测 Kafka 在规模运行中的性能成为一个日益重要的问题。监测端到端性能，要求跟踪所有指标，包括 Broker、消费者和生产者。除此之外还要监测 ZooKeeper，Kafka 用它来协调各个消费者。当前有一些监测平台可以跟踪卡夫卡的性能，有开源的，如领英的 Burrow；也有付费的，如 Datadog。除了这些平台之外，收集 Kafka 的数据也可以使用工具来进行，这些工具一般需要 Java，包括 JConsole。</p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>Kafaka是基于是JVM运行的程序，所有我们需要先安装JDK或者JRE。<code>(这里就看到了我们的Golang优势！！！！直接编译二进制啊哈哈哈~)</code></p><p><strong>需要Java 1.7或更高版本。因此，您可以如下安装OpenJDK 8</strong></p><pre><code class="shell">sudo yum install -y java-1.13.0-openjdk-devel</code></pre><p><strong>安装了OpenJDK 8后，请使用以下命令验证结果。</strong></p><pre><code class="shell">java -version</code></pre><p><strong>如果一切顺利，输出应与此类似。</strong></p><pre><code class="shelL">openjdk version &quot;1.8.0_252&quot;OpenJDK Runtime Environment (build 1.8.0_252-b09)OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)</code></pre><p><strong>最后，设置JAVA_HOME环境变量。</strong></p><pre><code class="shell">echo &quot;JAVA_HOME=$(readlink -f /usr/bin/java | sed &quot;s:bin/java::&quot;)&quot; | sudo tee -a /etc/profilesource /etc/profile</code></pre><p><strong>安装Kafka</strong></p><pre><code class="shell">wget https://downloads.apache.org/kafka/2.4.1/kafka_2.12-2.4.1.tgz</code></pre><p><strong>解压到opt目录</strong></p><pre><code class="SHELL"> tar -xvf kafka_2.12-2.4.1.tgz -C /opt/</code></pre><p>进入Kafka目录</p><p><code>cd /opt/kafka_2.11-0.9.0.1</code><br>启动Zookeeper服务器</p><p><code>bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</code></p><p>修改Kafka服务器的配置</p><p> <code>vi bin/kafka-server-start.sh</code></p><p>根据您的特定系统参数调整内存使用量。</p><p><code>export KAFKA_HEAP_OPTS=&quot;-Xmx1G -Xms1G&quot;</code></p><p>替换为：</p><p><code>export KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms128M&quot;</code></p><p>保存退出：</p><p><code>:wq</code></p><p>启动Kafka服务器</p><p><code>bin/kafka-server-start.sh config/server.properties</code></p><p>如果一切顺利，您将看到一些有关Kafka服务器状态的消息，最后一条将显示：</p><p><code>INFO [Kafka Server 0], started (kafka.server.KafkaServer)</code></p><p>这意味着您已经启动了Kafka服务器。</p><p>在新的SSH连接中创建主题“测试”</p><p>打开一个新的SSH连接，使用以下命令创建主题“ test”：</p><pre><code class="shell">cd /opt/kafka_2.11-0.9.0.1bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre><p>您可以使用以下命令查看主题：</p><pre><code class="shell">bin/kafka-topics.sh --list --zookeeper localhost:2181</code></pre><p>在我们的例子中，输出将显示为：</p><pre><code class="shell">test</code></pre><p>使用主题“测试”生成消息</p><pre><code class="shell">bin/kafka-console-producer.sh --broker-list localhost:9092 </code></pre><p><code>--topic test</code><br>使用上面的命令，您可以根据需要输入任意数量的消息，例如：</p><pre><code class="shell">Welcome aboard!Bonjour!</code></pre><p>如果您收到与”WARN Error while fetching metadata with correlation id”输入消息时类似的错误，则需要server.properties使用以下信息更新文件：</p><pre><code class="shell">port = 9092advertised.host.name = localhost </code></pre><p>打开第三个SSH连接，然后运行以下命令：</p><pre><code class="shell">cd /opt/kafka_2.11-0.9.0.1bin/kafka-console-consumer.sh --zookeeper localhost:9092 --topic test --from-beginning</code></pre><ul><li>您先前生成的消息将显示在第三个SSH连接中。当然，如果您现在从第二个SSH连接输入更多消息，您将立即在第三个SSH连接上看到它们。</li></ul><p>最后，您可以在每个SSH连接上按Ctrl + C组合键以停止这些脚本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Centos7</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSQ之弹射起步</title>
    <link href="/2020/05/19/NSQ%E4%B9%8B%E5%BC%B9%E5%B0%84%E8%B5%B7%E6%AD%A5/"/>
    <url>/2020/05/19/NSQ%E4%B9%8B%E5%BC%B9%E5%B0%84%E8%B5%B7%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gey1a5ssbvj30p00dw77v.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="NSQ是什么？？？"><a href="#NSQ是什么？？？" class="headerlink" title="NSQ是什么？？？"></a><code>NSQ</code>是什么？？？</h2><p><strong><code>NSQ</code>是<code>Go</code>语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。 NSQ的优势有以下优势：</strong></p><ul><li><code>NSQ</code>提倡分布式和分散的拓扑，没有单点故障，支持容错和高可用性，并提供可靠的消息交付保证</li><li><code>NSQ</code>支持横向扩展，没有任何集中式代理。</li><li><code>NSQ</code>易于配置和部署，并且内置了管理界面。</li></ul><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列?"></a>什么是消息队列?</h2><p>通俗地解释一下消息队列，你想象一个场景：你到报社订阅了一份报纸，报社每日生产一份新报纸，便将新报纸发往邮局并告诉邮局你的地址，邮递员将你的报纸送往你的邮箱，你便可以愉快地阅读今天的时事新闻了。当然，可能一个人订阅了好几家报社，一家报社也可以被多个人订阅。在这个场景中，消息队列就担任了，邮箱、邮局、邮递员的角色。</p><h2 id="消息队列的作用？"><a href="#消息队列的作用？" class="headerlink" title="消息队列的作用？"></a>消息队列的作用？</h2><ul><li>是减少相应所需的时间和削峰</li><li>降低系统耦合性解耦或提升系统的可拓展性）</li></ul><p><strong>如图下场景:</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gextpsdc8qj313e0u0wja.jpg" srcset="/img/loading.gif" alt="nsq"><br><strong>通过使用消息队列将不同的业务逻辑解耦，降低系统间的耦合，提高系统的健壮性。后续有其他业务要使用订单数据可直接订阅消息队列，提高系统的灵活性。</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gextqm9slzj30wi0jg409.jpg" srcset="/img/loading.gif" alt="nsq"><br><strong>还可以帮大并发做流量抗压处理，类似秒杀（大秒）等场景下，某一时间可能会产生大量的请求，使用消息队列能够为后端处理请求提供一定的缓冲区，保证后端服务的稳定性。</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gextrsvl7uj30xc08uwf9.jpg" srcset="/img/loading.gif" alt="nsq"></p><h2 id="开始NSQ弹射起步🚀"><a href="#开始NSQ弹射起步🚀" class="headerlink" title="开始NSQ弹射起步🚀"></a>开始<code>NSQ</code>弹射起步🚀</h2><p><strong>NSQ工作模式👇</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexu2qzvroj31480u0792.jpg" srcset="/img/loading.gif" alt="nsq"></p><p><code>Topic</code>和<code>Channel</code><br>每个<code>nsqd</code>实例旨在一次处理多个数据流。这些数据流称为<code>“topics”</code>，一个<code>topic</code>具有1个或多个<code>“channels”</code>。每个<code>channel</code>都会收到<code>topic</code>所有消息的副本，实际上下游的服务是通过对应的<code>channel</code>来消费<code>topic</code>消息。</p><p><code>topic</code>和<code>channel</code>不是预先配置的。<code>topic</code>在首次使用时创建，方法是将其发布到指定<code>topic</code>，或者订阅指定<code>topic</code>上的<code>channel</code>。<code>channel</code>是通过订阅指定的<code>channel</code>在第一次使用时创建的。</p><p><code>topic</code>和<code>channel</code>都相互独立地缓冲数据，防止缓慢的消费者导致其他<code>chennel</code>的积压（同样适用于<code>topic</code>级别）。</p><p><code>channel</code>可以并且通常会连接多个客户端。假设所有连接的客户端都处于准备接收消息的状态，则每条消息将被传递到随机客户端。例如：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexw4g26pog30bo07tjry.gif" srcset="/img/loading.gif" alt="nsq"><br>总而言之，消息是从<code>topic -&gt; channel</code>（每个<code>channel</code>接收该<code>topic</code>的所有消息的副本）多播的，但是从<code>channel -&gt; consumers</code>均匀分布（每个消费者接收该<code>channel</code>的一部分消息）。<br><strong>NSQ接收和发送消息流程</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexu6v1zghj30fc07paah.jpg" srcset="/img/loading.gif" alt=""><br><strong>NSQ特性</strong><br>消息默认不持久化，可以配置成持久化模式。nsq采用的方式时内存+硬盘的模式，当内存到达一定程度时就会将数据持久化到硬盘。</p><ul><li>如果将<code>--mem-queue-size</code>设置为0，所有的消息将会存储到磁盘。</li><li>服务器重启时也会将当时在内存中的消息持久化。</li><li>每条消息至少传递一次。</li><li>消息不保证有序。</li></ul><h3 id="开始使用NSQ"><a href="#开始使用NSQ" class="headerlink" title="开始使用NSQ"></a>开始使用<code>NSQ</code></h3><p>首先我们需要安装NSQ的<code>nsqlookupd</code>组件也就是<code>nsqd</code>程序,浏览器打开<a href="https://nsq.io/deployment/installing.html" target="_blank" rel="noopener">官方下载页面</a>即可得到你对应操作系统的程序。<br><strong><code>nsqd</code>是一个守护进程，它接收、排队并向客户端发送消息。</strong></p><h3 id="nsqlookupd组件"><a href="#nsqlookupd组件" class="headerlink" title="nsqlookupd组件"></a><code>nsqlookupd</code>组件</h3><p><code>nsqlookupd</code>相当于集群的管理员所以我们首先启动它</p><pre><code class="shell">$ nsqlookupd</code></pre><h3 id="nsqd组件"><a href="#nsqd组件" class="headerlink" title="nsqd组件"></a><code>nsqd</code>组件</h3><p>启动 <code>nsqd</code>，它相当于集群下的节点，是主要干活的</p><pre><code class="shell">$ nsqd --lookupd-tcp-address=127.0.0.1:4160</code></pre><p><strong><code>nsqlookupd</code>是维护所有<code>nsqd</code>状态、提供服务发现的守护进程。它能为消费者查找特定<code>topic</code>下的<code>nsqd</code>提供了运行时的自动发现服务。 它不维持持久状态，也不需要与任何其他<code>nsqlookupd</code>实例协调以满足查询。因此根据你系统的冗余要求尽可能多地部署<code>nsqlookupd</code>节点。它们消耗的资源很少，可以与其他服务共存。我们的建议是为每个数据中心运行至少3个集群。</strong></p><h3 id="nsqadmin组件"><a href="#nsqadmin组件" class="headerlink" title="nsqadmin组件"></a><code>nsqadmin</code>组件</h3><p>一个实时监控集群状态、执行各种管理任务的Web管理平台。 启动<code>nsqadmin</code>，指定<code>nsqlookupd</code>地址:</p><pre><code class="shell"> ./nsqadmin -lookupd-http-address=127.0.0.1:4161</code></pre><p>我们可以使用浏览器打开<code>http://127.0.0.1:4171/</code>访问如下管理界面。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvk9mzt7j31c00u0b29.jpg" srcset="/img/loading.gif" alt="nsq"></p><h3 id="测试消息"><a href="#测试消息" class="headerlink" title="测试消息"></a>测试消息</h3><p>发送一条消息</p><pre><code class="shell">$ curl -d &#39;hello world 1&#39; &#39;http://127.0.0.1:4151/pub?topic=test&#39;</code></pre><p>即可看到收到了消息<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvqdbqrrj31740u0k9x.jpg" srcset="/img/loading.gif" alt="nsq"><br>把消息写到硬盘的文件里</p><pre><code class="shell">$ nsq_to_file --topic=test --output-dir=/tmp --lookupd-http-address=127.0.0.1:4161</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvtcplxej312i0u07c5.jpg" srcset="/img/loading.gif" alt="nsq"><br>文件内容<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvukbk33j31ja0m614z.jpg" srcset="/img/loading.gif" alt="nsq"></p><p><strong>好了如果对你有帮助你可以到本博客的关于页面添加我微信或者在Github联系我，一起推动Golang在中国这片土地生根发芽长成大树！！！Good luck!</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>NSQ</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gohper成长秘籍</title>
    <link href="/2020/05/17/Gohper%E7%9A%84300%E9%97%AE/"/>
    <url>/2020/05/17/Gohper%E7%9A%84300%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevv4s06cej30dw04zjs2.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>这是我个人<code>Denn</code>整理的一套Golang学习目录<br> ✅ 表示我已经完成的<br> 🤷‍♀️ 表示我了解过没有深入<br> 加油各位少年🍻</p></blockquote><h1 id="目录树🌲"><a href="#目录树🌲" class="headerlink" title="目录树🌲"></a>目录树🌲</h1><ul><li>常量和变量的关系 ✅</li><li>基本数据类型和引用类型  ✅</li><li>程序的运算符  ✅</li><li>程序控制流程  ✅</li><li>数组的使用  ✅</li><li><code>slice</code>、<code>map</code>、<code>channel</code>的使用  ✅</li><li>函数式编程  ✅</li><li>结构体和指针  ✅</li><li>面向接口编程  ✅</li><li>包和目录的概念  ✅</li><li>反射和不安全编程 🤷‍♀️</li><li>测试包的使用  ✅</li><li>常用的内置的使用  ✅</li><li><code>Goroutine</code>和<code>Comtext</code>  ✅</li><li>网络编程和数据库编程  ✅<ul><li><code>Gin</code></li><li><code>Gorm</code></li><li><code>gRPC</code> </li><li><code>Redis</code></li><li><code>Nsq</code></li><li><code>Kafka</code></li><li><code>MongoDB</code></li><li><code>Etcd</code></li><li><code>ElasticSearch</code></li><li><code>......还有跟多需要不断努力🏃‍♀️</code></li></ul></li><li>算法和数据结构补一补</li><li>找一些计算机组成和计算机基础视频看看~</li><li>Good Luck！！！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go性能分析之PProf</title>
    <link href="/2020/05/16/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8BPProf/"/>
    <url>/2020/05/16/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8BPProf/</url>
    
    <content type="html"><![CDATA[<h2 id="PProf是个啥？？？"><a href="#PProf是个啥？？？" class="headerlink" title="PProf是个啥？？？"></a>PProf是个啥？？？</h2><p><code>pprof</code>是用于可视化和分析性能分析数据的工具,<code>pprof</code>以 <code>profile.proto</code> 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）<br><code>profile.proto</code> 是一个<code>Protocol Buffer v3</code>的描述文件，它描述了一组 <code>callstack</code>和 <code>symbolization</code>信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 <code>stacktrace</code>配置文件格式。</p><ol><li>支持什么使用模式<ul><li><code>Report generation</code>：报告生成</li><li><code>Interactive terminal use</code>：交互式终端使用</li><li><code>Web interface</code>：<code>Web</code> 界面</li></ul></li><li>可以做什么<ul><li><code>CPU Profiling</code>：<code>CPU</code> 分析，按照一定的频率采集所监听的应用程序 <code>CPU</code>（含寄存器）的使用情况，可确定应用程序在主动消耗 <code>CPU</code> 周期时花费时间的位置</li><li><code>Memory Profiling</code>：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li><li><code>Block Profiling</code>：阻塞分析，记录 <code>goroutine</code> 阻塞等待同步（包括定时器通道）的位置</li><li><code>Mutex Profiling</code>：互斥锁分析，报告互斥锁的竞争情况</li></ul></li></ol><h2 id="一个例子🌰"><a href="#一个例子🌰" class="headerlink" title="一个例子🌰"></a>一个例子🌰</h2><p><strong>想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：</strong></p><ul><li><code>runtime/pprof</code>：采集程序（<code>非 Server</code>）的运行数据进行分析</li><li><code>net/http/pprof</code>：采集 <code>HTTP Server</code> 的运行时数据进行分析</li></ul><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/16 - 12:53 下午package mainimport (    &quot;flag&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;runtime/pprof&quot;    &quot;time&quot;)// 一段有问题的代码func logicCode() {    var c chan int    for {        select {        case v := &lt;-c:            fmt.Printf(&quot;recv from chan, value:%v\n&quot;, v)        default:        }    }}func main() {    var isCPUPprof bool    var isMemPprof bool    flag.BoolVar(&amp;isCPUPprof, &quot;cpu&quot;, false, &quot;turn cpu pprof on&quot;)    flag.BoolVar(&amp;isMemPprof, &quot;mem&quot;, false, &quot;turn mem pprof on&quot;)    flag.Parse()    if isCPUPprof {         file, err := os.Create(&quot;./cpu.pprof&quot;)        if err != nil {            fmt.Printf(&quot;create cpu pprof failed, err:%v\n&quot;, err)            return        }        pprof.StartCPUProfile(file)        defer pprof.StopCPUProfile()    }    for i := 0; i &lt; 8; i++ {        go logicCode()    }    time.Sleep(20 * time.Second)    if isMemPprof {        file, err := os.Create(&quot;./mem.pprof&quot;)        if err != nil {            fmt.Printf(&quot;create mem pprof failed, err:%v\n&quot;, err)            return        }        pprof.WriteHeapProfile(file)        file.Close()    }}</code></pre><p><strong>可以看到👆上面的那个<code>select</code>代码块里面的channel没有初始化，会一直阻塞着。这样一个简单的代码可以通过我们肉眼出来了，但是如果是复杂的我们就需要使用<code>pprof</code>工具了。</strong></p><pre><code class="shell">$: go tool pprof cpu.pprof Type: cpuTime: May 16, 2020 at 12:59pm (CST)Duration: 20.14s, Total samples = 56.90s (282.48%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) top3Showing nodes accounting for 51.91s, 91.23% of 56.90s totalDropped 7 nodes (cum &lt;= 0.28s)Showing top 3 nodes out of 4      flat  flat%   sum%        cum   cum%    23.04s 40.49% 40.49%     45.18s 79.40%  runtime.selectnbrecv    17.26s 30.33% 70.83%     18.93s 33.27%  runtime.chanrecv    11.61s 20.40% 91.23%     56.83s 99.88%  main.logicCode //❎这里已经通过工具分析出来了！！！</code></pre><p><strong>工具就可以分析出来了我们的<code>logicCode</code>函数有问题！</strong></p><pre><code class="shell">$: go tool pprof cpu.pprof Type: cpuTime: May 16, 2020 at 12:59pm (CST)Duration: 20.14s, Total samples = 56.90s (282.48%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) top3Showing nodes accounting for 51.91s, 91.23% of 56.90s totalDropped 7 nodes (cum &lt;= 0.28s)Showing top 3 nodes out of 4      flat  flat%   sum%        cum   cum%    23.04s 40.49% 40.49%     45.18s 79.40%  runtime.selectnbrecv    17.26s 30.33% 70.83%     18.93s 33.27%  runtime.chanrecv    11.61s 20.40% 91.23%     56.83s 99.88%  main.logicCode(pprof) list logicCodeTotal: 56.90sROUTINE ======================== main.logicCode in /Users/ding/Documents/GO_CODE_DEV/src/Lets_Go/lets_37_pprof/main.go    11.61s     56.83s (flat, cum) 99.88% of Total         .          .     16:// 一段有问题的代码         .          .     17:func logicCode() {         .          .     18:   var c chan int         .          .     19:   for {         .          .     20:           select {    11.61s     56.83s     21:           case v := &lt;-c:         .          .     22:                   fmt.Printf(&quot;recv from chan, value:%v\n&quot;, v)         .          .     23:           default:         .          .     24:         .          .     25:           }         .          .     26:   }(pprof) </code></pre><p><strong>通过<code>list funcName</code>就可以定位到哪行代码的问题了！当然<code>PProf</code>工具的用途多的是这里就是一个简单的例子，我这篇博文就写到这里，有兴趣的后面再更新，或者关注我的公众号:<code>go_code</code>谢谢里面有干货哦<del>~</del>🤩</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>PPorf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Testing of Golang</title>
    <link href="/2020/05/15/Testing-of-Golang/"/>
    <url>/2020/05/15/Testing-of-Golang/</url>
    
    <content type="html"><![CDATA[<h2 id="GoLang的单元测试"><a href="#GoLang的单元测试" class="headerlink" title="GoLang的单元测试"></a>GoLang的单元测试</h2><p>在我们写代码的过程中要养成一个写注释和写单元测试的习惯，这样可以提高我们的代码健壮性和可读性，今天我们就来介绍一下<code>golang</code>的<code>test</code>这个工具。</p><h2 id="go-test命令介绍"><a href="#go-test命令介绍" class="headerlink" title="go test命令介绍"></a><code>go test</code>命令介绍</h2><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p><p><code>go test</code>命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th>类型</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td>测试函数</td><td>函数名前缀为<code>Test</code></td><td>测试程序的一些逻辑行为是否正确</td></tr><tr><td>基准函数</td><td>函数名前缀为<code>Benchmark</code></td><td>测试函数的性能</td></tr><tr><td>示例函数</td><td>函数名前缀为<code>Example</code></td><td>为文档提供示例文档</td></tr></tbody></table><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><blockquote><p>基本测试的一些方法说明在文档里:<a href="https://studygolang.com/static/pkgdoc/pkg/testing.htm" target="_blank" rel="noopener">https://studygolang.com/static/pkgdoc/pkg/testing.htm</a></p></blockquote><p><strong>本测试的函数<code>math.go</code></strong></p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/15 - 4:16 下午package lets_36_testingfunc init() {    Math := make(map[string]func(n, m int) int, 4)    Math[&quot;add&quot;] = Add    Math[&quot;sub&quot;] = Sub    Math[&quot;multi&quot;] = Multi    Math[&quot;div&quot;] = Div}func Add(n, m int) int {    return n + m}func Sub(n, m int) int {    return n - m}func Multi(n, m int) int {    return n * m}func Div(n, m int) int {    return n / m}</code></pre><p><strong>测试函数<code>math_test.go</code>遵循官方命名规范</strong></p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/15 - 4:21 下午package lets_36_testingimport &quot;testing&quot;func TestMath(t *testing.T) {    // 自定义测试结构体    type MathCase struct {        n, m, result int    }    // 自定义子测试map    testGroup := map[string]MathCase{        &quot;add&quot;:   {1, 2, 3},        &quot;sub&quot;:   {3, 1, 2},        &quot;multi&quot;: {3, 2, 6},        &quot;div&quot;:   {6, 2, 3},    }    // 测试执行函数    for name, mathCase := range testGroup {        t.Run(name, func(t *testing.T) {            s := -1            switch name {            case &quot;add&quot;:                s = Add(mathCase.n, mathCase.m)            case &quot;sub&quot;:                s = Sub(mathCase.n, mathCase.m)            case &quot;multi&quot;:                s = Multi(mathCase.n, mathCase.m)            case &quot;div&quot;:                s = Div(mathCase.n, mathCase.m)            default:                t.Fatalf(&quot;No executable testing name :%s&quot;, name)            }            if mathCase.result != s {                t.Fatalf(&quot; add computer result error， want %d , got %d&quot;, mathCase.result, s)            }        })    }}</code></pre><p><strong>在自己的terminal输入<code>go test</code>即可看到测试结果</strong></p><pre><code class="go">=== RUN   TestMath=== RUN   TestMath/sub=== RUN   TestMath/multi=== RUN   TestMath/div=== RUN   TestMath/add--- PASS: TestMath (0.00s)    --- PASS: TestMath/sub (0.00s)    --- PASS: TestMath/multi (0.00s)    --- PASS: TestMath/div (0.00s)    --- PASS: TestMath/add (0.00s)PASSok      command-line-arguments  0.004s</code></pre><blockquote><p>如果是子测试可以加 <code>-run=funcName/TestCase</code>来进行子测试</p></blockquote><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。Go提供内置功能来检查你的代码覆盖率。我们可以使用<code>go test -cover</code>来查看测试覆盖率，例如：</p><pre><code class="go">$: go test -coverPASScoverage: 100.0% of statementsok      Lets_Go/lets_36_testing 0.004s</code></pre><p><strong>可以看到我的代码测试覆盖率是百分之百的~</strong></p><p>Go还提供了一个额外的<code>go test -cover -coverprofile</code>参数，用来将覆盖率相关的记录信息输出到一个文件里:</p><pre><code class="go">$: go test -cover -coverprofile=testInfo.out[50 50 50 50 50 50]PASScoverage: 100.0% of statementsok      Lets_Go/lets_36_testing 0.005s</code></pre><p><strong>这样我们就把测试的信息输出到一个指定的<code>testInfo.out</code>文件里面了,然后我们通过go语言内置<code>tool</code>工具就可以生产可视化的代码覆盖率检查视图了，使用命令<code>go tool cover -html=testInfo.out</code>例如:</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getd9mki8bj313u0u0dve.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>基准测试是给你的程序做运行性能的测试,以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。</p><pre><code class="go">func BenchmarkAdd(b *testing.B) {    for i:=0;i&lt;b.N;i++ {        Add(i, b.N)        //fmt.Println(add)    }}</code></pre><p><strong>增加<code>-bench</code>参数，所以我们通过执行<code>go test -bench=Add</code>命令执行基准测试，输出结果如下</strong></p><pre><code class="go">$: go test -bench=Addgoos: darwingoarch: amd64pkg: Lets_Go/lets_36_testingBenchmarkAdd-4          1000000000               0.281 ns/opPASSok      Lets_Go/lets_36_testing 0.320s</code></pre><p><strong>其中BenchmarkAdd-4表示对Split函数进行基准测试，数字4表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Add函数耗时0.281ns，这个结果是10000000次调用的平均值。</strong></p><p>还可以添加<code>-benchmem</code>参数来查看被查内存使用情况:</p><pre><code class="go">$: go test -bench=Add -benchmemgoos: darwingoarch: amd64pkg: Lets_Go/lets_36_testingBenchmarkAdd-4          1000000000               0.292 ns/op           0 B/op          0 allocs/opPASSok      Lets_Go/lets_36_testing 0.335s</code></pre><p><strong><code>0 B/op</code>表示每次操作内存分配了<code>0</code>字节，<code>0 allocs/op</code>则表示每次操作进行了<code>0</code>次内存分配,因为我写的就是一个简单加法函数😁</strong></p><blockquote><p>Good luck😜~</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sync.Mutex&amp;RWMutex笔记</title>
    <link href="/2020/05/12/sync-Mutex-RWMutex%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/05/12/sync-Mutex-RWMutex%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-中锁的使用"><a href="#Go-中锁的使用" class="headerlink" title="Go 中锁的使用"></a>Go 中锁的使用</h2><ol><li>互斥锁</li><li>读写锁</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepy9opn7vj30ge0gq3yz.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>并发程序对公共资源访问的限制最常见的就是使用互斥锁的方式。在Go中，sync.Mutex 提供了互斥锁的实现。</p><p>简单使用示例：</p><pre><code class="go">func main() {var mutex sync.Mutexcount := 0for r := 0; r &lt; 50; r++ {   go func() {           mutex.Lock()           count += 1           mutex.Unlock()       }()   }   time.Sleep(time.Second)   fmt.Println(&quot;the count is : &quot;, count)}</code></pre><p>当执行了 <code>mutex.Lock()</code> 操作后，如果有另外一个 <code>goroutine</code> 又执行了上锁操作，那么该操作被被阻塞，直到该互斥锁恢复到解锁状态。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>顾名思义，读写锁是对读写操作进行加锁。需要注意的是多个读操作之间不存在互斥关系，这样提高了对共享资源的访问效率。</p><p>Go中读写锁由 <code>sync.RWMutex</code>提供，主要包括：</p><ul><li><p><code>func (rw *RWMutex) Lock()</code></p></li><li><p><code>func (rw *RWMutex) RLock()</code></p></li><li><p><code>func (rw *RWMutex) RLocker() Locker</code></p></li><li><p><code>func (rw *RWMutex) RUnlock()</code></p></li><li><p><code>func (rw *RWMutex) Unlock()</code></p></li></ul><p>其中 <code>Lock()</code> 即“写锁定”，调用了“写锁定”后，不能有其他<code>goroutine</code>进行读或者写操作。 <code>Unlock()</code> 即“写解锁”，调用了“写解锁”后会唤醒所有因为要进行“读锁定（即:<code>RLock()</code>）” 而被阻塞的 <code>goroutine</code>。</p><p><code>RLock()</code>为“读锁定”，调用“读锁定”后，不能有其他<code>goroutine</code>进行写操作，但是可以进行读操作。<code>RUnlock()</code> 为“读解锁”，调用“读解锁”后，会唤醒一个因为要进行“写锁定”而被阻塞的<code>goroutine</code>。</p><p>简单使用示例：</p><pre><code class="go">package mainimport (&quot;fmt&quot;&quot;sync&quot;&quot;time&quot;)func main() {    var mutex sync.RWMutex    arr := []int{1, 2, 3}    go func() {       fmt.Println(&quot;Try to lock writing operation.&quot;)       mutex.Lock()       fmt.Println(&quot;Writing operation is locked.&quot;)       arr = append(arr, 4)       fmt.Println(&quot;Try to unlock writing operation.&quot;)       mutex.Unlock()       fmt.Println(&quot;Writing operation is unlocked.&quot;)   }()   go func() {       fmt.Println(&quot;Try to lock reading operation.&quot;)       mutex.RLock()       fmt.Println(&quot;The reading operation is locked.&quot;)       fmt.Println(&quot;The len of arr is : &quot;, len(arr))       fmt.Println(&quot;Try to unlock reading operation.&quot;)       mutex.RUnlock()       fmt.Println(&quot;The reading operation is unlocked.&quot;)   }()   time.Sleep(time.Second * 2)   return}</code></pre><p>运行以上示例，观察输出结果，你将能够比较直观的感受到读写锁的作用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>读写锁</tag>
      
      <tag>Mutex</tag>
      
      <tag>RWMutex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP黏包</title>
    <link href="/2020/05/11/TCP%E9%BB%8F%E5%8C%85/"/>
    <url>/2020/05/11/TCP%E9%BB%8F%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包?"></a>什么是TCP粘包?</h2><ol><li>通常我在自己写程序的时候写一个基于<code>tcp</code>协议通讯的程序时就会发生这种问题。</li><li>我们在<code>Client</code>端快速发送数据包并且这个包数据是随机,时间间隔也很短,然后<code>tcp</code>的<code>Server</code>拿到数据就会是我们之前<code>Client</code>发送的多条数据包合在的一起的，导致我们不能区分具体是哪个数据包的。</li><li>为什么会产生这种原因就是因为<code>tcp</code>在传输的是<code>字节流协议</code>。<blockquote><p>上面是我个人自学习过程中总结的大家可以看看这个链接上的解释:<br><a href="https://www.liwenzhou.com/posts/Go/15_socket/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/15_socket/</a></p></blockquote></li></ol><h2 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h2><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ul><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geosakdma0j30on0brabp.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="通过Go语言实现"><a href="#通过Go语言实现" class="headerlink" title="通过Go语言实现"></a>通过Go语言实现</h2><blockquote><p>server.go</p></blockquote><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/11 - 7:14 下午package mainimport (    &quot;fmt&quot;    &quot;net&quot;)func main() {    listen, err := net.Listen(&quot;tcp&quot;, &quot;localhost:9598&quot;)    if err != nil {        fmt.Println(&quot;create tcp server fail.&quot;,err)        return    }    var msg [1024]byte    for{        accept, err := listen.Accept()        if err != nil {            fmt.Println(&quot;tcp accept fail&quot;,err)            return        }        n , _ := accept.Read(msg[:])        fmt.Println(string(msg[:n]))    }}</code></pre><blockquote><p>client.go</p></blockquote><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/11 - 7:58 下午package mainimport (    &quot;fmt&quot;    &quot;net&quot;    &quot;time&quot;)func main() {    dial, err := net.Dial(&quot;tcp&quot;, &quot;localhost:9598&quot;)    if err != nil {        fmt.Println(&quot;connection tcp server fail.&quot;,err)    }    for i:=0;i&lt;10;i++ {        dial.Write([]byte(&quot;Hello&quot; + time.Now().Format(&quot;2006-01-02 15:04:05.0000&quot;)))    }}</code></pre><blockquote><p>OutPut</p></blockquote><pre><code> ~/Documents/GO_CODE_DEV/src/Lets_Go/lets_33_tcp_黏包  master ✚  ↵ 1  go run server.goHello2020-05-11 20:16:13.5448Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449</code></pre><p><strong>可以看到所有数据包都被黏在一起了！！！！这就是我们所说的tcp黏包。</strong></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>出现黏包的原因是因为服务器端或者消息接受者不知道我们每次发送的数据包大小！！所以我们可以自定义一个数据包格式来解决。就像我们出去约别人吃饭一样的，我们俩先商量好去哪里地方几点…..(例子有点抽象不好理解啊哈哈哈)</p></blockquote><blockquote><p>protocol.go</p></blockquote><pre><code class="go">package mainimport (    &quot;bufio&quot;    &quot;bytes&quot;    &quot;encoding/binary&quot;)// Encode 将消息编码func Encode(message string) ([]byte, error) {    // 读取消息的长度，转换成int32类型（占4个字节）    var length = int32(len(message))    // 创建缓冲区    var pkg = new(bytes.Buffer)    // 写入消息头 “小端方式写入存储”这里我也不太清楚看别人写的例子,用就完事了    err := binary.Write(pkg, binary.LittleEndian, length)    if err != nil {        return nil, err    }    // 在包头后面 追加 写入消息实体    err = binary.Write(pkg, binary.LittleEndian, []byte(message))    if err != nil {        return nil, err    }    return pkg.Bytes(), nil}// Decode 解码消息func Decode(reader *bufio.Reader) (string, error) {    // 读取消息的长度    lengthByte, _ := reader.Peek(4) // 读取前4个字节的数据    lengthBuff := bytes.NewBuffer(lengthByte)    var length int32    err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)    if err != nil {        return &quot;&quot;, err    }    // Buffered返回缓冲中现有的可读取的字节数。    if int32(reader.Buffered()) &lt; length+4 {        return &quot;&quot;, err    }    // 读取真正的消息数据    pack := make([]byte, int(4+length))    _, err = reader.Read(pack)    if err != nil {        return &quot;&quot;, err    }    return string(pack[4:]), nil}</code></pre><p><strong>接下来在服务端和客户端分别使用上面定义的Decode和Encode函数处理数据。下面有我的源代码仓库,Good Luck~😜</strong><br><strong><a href="https://github.com/higker/Lets_Go/tree/master/lets_33_tcp_%E9%BB%8F%E5%8C%85" target="_blank" rel="noopener">https://github.com/higker/Lets_Go/tree/master/lets_33_tcp_%E9%BB%8F%E5%8C%85</a></strong></p><h2 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h2><blockquote><p>为什么udp不会粘包?<br><a href="https://zhuanlan.zhihu.com/p/41709589?utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41709589?utm_source=wechat_session</a></p></blockquote><p>1.TCP协议是面向流的协议，UDP是面向消息的协议</p><p>UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据</p><p>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说就容易进行区分处理了。传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。接收端一次只能接收发送端发出的一个数据包,如果一次接受数据的大小小于发送端一次发送的数据大小，就会丢失一部分数据，即使丢失，接受端也不会分两次去接收</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈并发和并行</title>
    <link href="/2020/05/08/%E8%B0%88%E8%B0%88%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
    <url>/2020/05/08/%E8%B0%88%E8%B0%88%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是并发？"><a href="#什么是并发？" class="headerlink" title="什么是并发？"></a>什么是并发？</h2><p> 就是在一段时间里来回切换做多个事情，就像一个快递员在一分钟内送完我的快递又继续去送的快递，干活的就只要一个快递员(这个例子有点不好还是看下面图片吧)。<code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelclh44mgj308704j74e.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么并行？"><a href="#什么并行？" class="headerlink" title="什么并行？"></a>什么并行？</h2><p>在同一时刻内处理多个事情，就像一个2个快递员在同时时间内分别给你我送快递。(他们2个在同一个时间内同时干活，效率高)。<code>并行(parallel)：</code>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geldwbtva1j308p04mgln.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么区别？"><a href="#什么区别？" class="headerlink" title="什么区别？"></a>什么区别？</h2><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发（Concurrent）。</p><p>当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行（Parallel）。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geld285ybjj30i40ea750.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>看图非常容易理解：</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geld3btporj30o909faaz.jpg" srcset="/img/loading.gif" alt=""><br>上图中将一个任务中的三个步骤取柴、运柴、卸柴划分成了独立的小任务，有取柴的老鼠，有运柴的老鼠，有卸柴烧火的老鼠。<br>如果上图中所有的老鼠都是同一只，那么是串行并发的，如果是不同的多只老鼠，那么是并行并发的。</p><h4 id="并行和串行："><a href="#并行和串行：" class="headerlink" title="并行和串行："></a>并行和串行：</h4><ul><li>串行：一次只能取得一个任务并执行这一个任务</li><li>并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务</li><li>注意点：<ul><li>如果是单进程/单线程的并行，那么效率比串行更差</li><li>如果只有单核cpu，多进程并行并没有提高效率</li><li>从任务队列上看，由于同时从队列中取得多个任务并执行，相当于将一个长任务队列变成了短队列</li></ul></li></ul><h3 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h3><ul><li>并发是一种现象：同时运行多个程序或多个任务需要被处理的现象</li><li>这些任务可能是并行执行的，也可能是串行执行的，和CPU核心数无关，是操作系统进程调度和CPU上下文切换达到的结果</li><li>解决大并发的一个思路是将大任务分解成多个小任务：</li><li>可能要使用一些数据结构来避免切分成多个小任务带来的问题</li><li>可以多进程/多线程并行的方式去执行这些小任务达到高效率</li><li>或者以单进程/单线程配合多路复用执行这些小任务来达到高效率</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>计算机知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之高阶函数</title>
    <link href="/2020/04/24/Go%E4%B9%8B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2020/04/24/Go%E4%B9%8B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是高阶函数-？"><a href="#什么是高阶函数-？" class="headerlink" title="什么是高阶函数??？"></a>什么是高阶函数??？</h1><p>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数，编写高阶函数，就是让函数的参，能够接收别的函数，函数式编程就是指这种高度抽象的编程范式。</p><h1 id="高阶函数的特点"><a href="#高阶函数的特点" class="headerlink" title="高阶函数的特点"></a>高阶函数的特点</h1><ul><li>变量可以指向函数</li></ul><p><code>函数本身也可以赋值给变量，即：变量可以指向函数</code></p><pre><code class="go">package main//go语言导包import (    m &quot;Lets_Go/lets_18_package/math&quot; //起别名  自定义包名也就是给“math“起个别名    &quot;fmt&quot;)func main() {    multip := m.SimpleCompute(&quot;+&quot;)    fmt.Println(multip(2, 8))}</code></pre><ul><li>返回值也是函数</li></ul><pre><code class="go">/*    闭包高阶函数*/func SimpleCompute(Symbol string) func(n, m int) int {    switch Symbol {    case &quot;+&quot;:        return func(n, m int) int {            return n + m        }    case &quot;-&quot;:        return func(n, m int) int {            return n - m        }    case &quot;*&quot;:        return func(n, m int) int {            return n * m        }    case &quot;/&quot;:        return func(n, m int) int {            return n / m        }    default:        panic(&quot;compute symbol invalid.&quot;)    }}</code></pre><ul><li>函数可作为参数</li></ul><p><code>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数一个最简单的高阶函数</code></p><pre><code class="go">package mainimport &quot;fmt&quot;//go语言中的闭包操作func main() {    f1(f3(f2, 5, 5))}//1.限制函数类型的函数func f1(f func()) {    f()}//2.现在的需求就要把我们的f2函数传递到f1函数里面进行调用func f2(a, b int) int {    fmt.Println(&quot;f2() am f1() exec succeed&quot;)    fmt.Println(&quot;a + b = ? 在f3中的匿名函数中调用:&quot;)    return a + b}//3.通过闭包解决func f3(fn func(int, int) int, a, b int) (Rf func()) { //返回值名字必须是“Rf” 不想用就不需要写直接写返回值类型    //这个就是取一个中间变量存储 并且 在函数里面声明一个匿名无返回值的函数    // := 这里如果函数返回值已经在函数名上写着了 就不能使用 := 因为已经在创建函数时已经声明了    Rf = func() {        sum := fn(a, b) //接受返回值 然后打印        fmt.Println(&quot;sum=&quot;, sum)    }    return Rf}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之channel浅入了解</title>
    <link href="/2020/04/23/Go%E4%B9%8Bchannel%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/04/23/Go%E4%B9%8Bchannel%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Go语言的channel？"><a href="#什么是Go语言的channel？" class="headerlink" title="什么是Go语言的channel？"></a>什么是Go语言的channel？</h2><blockquote><p>在Go语言中,Channel即指通道类型。有时也用它来直接指代可以传递某种类型的值的通道。</p></blockquote><p>channel是Go语言中的一个核心类型，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯，这在一定程度上又进一步降低了编程的难度。<br>channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题。<br>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。<br>引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3kqrcxboj30dw072mxe.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="属性和基本操作"><a href="#属性和基本操作" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h2><ul><li>基于通道的通讯是在多个Goroutine之间进行同步的重要手段。而针对通道的操作本身也是同步的。</li><li>在同一时刻，仅有一个Goroutine能向一个通道发送元素值</li><li>同时也仅有一个Goroutine能从它那里接收元素值。</li><li>通道相当于一个FIFO先进先出的消息队列。</li><li>通道中的元素值都具有原子性。它们是不可被分割的。通道中的每一个元素都只可能被某一个Goroutine接收。已被接收的元素值会立刻被从通道中删除。</li></ul><h2 id="有缓冲的channel"><a href="#有缓冲的channel" class="headerlink" title="有缓冲的channel"></a>有缓冲的channel</h2><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个数据值的通道。<br>这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。<br>只有通道中没有要接收的值时，接收动作才会阻塞。<br>只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。<br>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p><p>示例图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3kigisnoj30m70ewtaf.jpg" srcset="/img/loading.gif" alt=""></p><p>在第 1 步，右侧的 goroutine 正在从通道接收一个值。<br>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道里。<br>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine 正在从通道接收另外一个值。这个步骤里的两个操作既不是同步的，也不会互相阻塞。<br>最后，在第 4 步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</p><p><em>使用示例</em></p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/4/22 - 3:15 下午package mainimport (    &quot;fmt&quot;    &quot;sync&quot;)var wg sync.WaitGroup//go语言的channel 通道//go语言使用goroutine执行多个task任务//操作一个map或者其他变量或者内存时会发生数据竞争//使用go里面使用channel来解决并发并行来解决func main() {    //channel类型 相当于一个队列 first in -&gt; first out 先进先出原则    //定义一个channel类型 channel是一个引用类型 需要开辟空间    var ch chan int    fmt.Println(ch == nil) //true    //初始化一个无缓冲区的通道    ch = make(chan int)    wg.Add(1)    go func (){        defer wg.Done()        x := &lt;- ch        fmt.Println(x)    }()    ch &lt;- 2048 //会卡死main的主goroutine从而不能让程序进行执行    fmt.Println(ch) //无缓冲区的channel不能放入值    fmt.Println(ch == nil) //false    //初始化一个带缓冲区的通道    bufChan := make(chan int,8)    fmt.Println(cap(bufChan)) //8 CAP可以换取通道缓冲区大小    //发送值 使用这个&quot;&lt;-符号&quot; 获取也一样    bufChan &lt;- 1024    num := &lt;-bufChan    fmt.Println(bufChan)    fmt.Println(num)    wg.Wait()}</code></pre><blockquote><p>上面部分内容转载于链接：<a href="https://www.jianshu.com/p/e611d30feb9d" target="_blank" rel="noopener">https://www.jianshu.com/p/e611d30feb9d</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>goroutine</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之goroutine浅入了解</title>
    <link href="/2020/04/22/Go%E4%B9%8Bgoroutine%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/04/22/Go%E4%B9%8Bgoroutine%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么goroutine"><a href="#1-什么goroutine" class="headerlink" title="1.什么goroutine?"></a>1.什么goroutine?</h1><p>goroutine是Go并行设计的核心。goroutine说到底其实就是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。<br>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p><p>Goroutine是建立在线程之上的轻量级的抽象。它允许我们以非常低的代价在同一个地址空间中并行地执行多个函数或者方法。相比于线程，它的创建和销毁的代价要小很多，并且它的调度是独立于线程的。在golang中创建一个goroutine非常简单，使用“go”关键字即可：</p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/4/21 - 6:09 下午package mainimport (    &quot;fmt&quot;    &quot;math/rand&quot;    &quot;sync&quot;    &quot;time&quot;)var (    //这个是go里面用来配置goroutine使用的    //只能操作指针 因为他是一个struct 值类型！！！    wg sync.WaitGroup    //存放我们for的数字方便观察    sls []int)//go语言中的多个goroutine//WaitGroupfunc main() {    fmt.Println(&quot;goroutine begin:&quot;, sls)    for i := 0; i &lt;= 10; i++ {        // fatal error: all goroutines are asleep - deadlock!        //注意这里加的1不是i如果是i的话每次都是加的不一样然后出现👆的异常！！！        wg.Add(1)        go task(i)    }    fmt.Println(&quot;InService:&quot;, sls)    wg.Wait()    fmt.Println(&quot;End Over:&quot;, sls)}// fatal error: all goroutines are asleep - deadlock!func task(num int) {    defer func() {        wg.Done()    }()    //随机休眠几毫秒    time.Sleep(duration())    //将for循环的i存入到切片中我们等下好观察,    //打印控制台太慢了回漏掉    sls = append(sls, num) //不安全}//生成一个随机的等待时间 = 毫秒func duration() time.Duration {    rand.Seed(time.Now().UnixNano())    return time.Millisecond * time.Duration(rand.Intn(3000))}</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code class="shell">goroutine begin: []InService: []End Over: [4 10 9 8 6 1 0 3 2]</code></pre><blockquote><p>会出现一个问题多次运行你会发现有时候结果的slice会少一个数,这是因为，和线程一样，golang的主函数（其实也跑在一个goroutine中）并不会等待其它goroutine结束。如果主goroutine结束了，所有其它goroutine都将结束,所有后面我们就会将到go的channel来解决问题~数据竞争和数据共享,多个goroutine之间的通讯问题。</p></blockquote><h3 id="Goroutine与线程的区别"><a href="#Goroutine与线程的区别" class="headerlink" title="Goroutine与线程的区别"></a>Goroutine与线程的区别</h3><p>许多人认为goroutine比线程运行得更快，这是一个误解。Goroutine并不会更快，它只是增加了更多的并发性。当一个goroutine被阻塞（比如等待IO），golang的scheduler会调度其它可以执行的goroutine运行。与线程相比，它有以下几个优点：</p><h3 id="内存消耗更少："><a href="#内存消耗更少：" class="headerlink" title="内存消耗更少："></a>内存消耗更少：</h3><p>Goroutine所需要的内存通常只有2kb，而线程则需要1Mb（500倍）。<br>内存消耗更少：</p><h3 id="创建与销毁的开销更小"><a href="#创建与销毁的开销更小" class="headerlink" title="创建与销毁的开销更小"></a>创建与销毁的开销更小</h3><p>由于线程创建时需要向操作系统申请资源，并且在销毁时将资源归还，因此它的创建和销毁的开销比较大。相比之下，goroutine的创建和销毁是由go语言在运行时自己管理的，因此开销更低。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2mjdldsfj30hs0a5q3h.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="切换开销更小"><a href="#切换开销更小" class="headerlink" title="切换开销更小"></a>切换开销更小</h3><p>这是goroutine于线程的主要区别，也是golang能够实现高并发的主要原因。线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，就会被其它可执行的线程抢占。在线程切换的过程中需要保存/恢复所有的寄存器信息，比如16个通用寄存器，PC（Program Counter），SP（Stack Pointer），段寄存器等等。</p><p>而goroutine的调度是协同式的，它不会直接地与操作系统内核打交道。当goroutine进行切换的时候，之后很少量的寄存器需要保存和恢复（PC和SP）。因此gouroutine的切换效率更高。</p><h3 id="Goroutine的调度"><a href="#Goroutine的调度" class="headerlink" title="Goroutine的调度"></a>Goroutine的调度</h3><p>真如前面提到的，goroutine的调度方式是协同式的。在协同式调度中，没有时间片的概念。为了并行执行goroutine，调度器会在以下几个时间点对其进行切换：</p><h3 id="Channel接受或者发送会造成阻塞的消息"><a href="#Channel接受或者发送会造成阻塞的消息" class="headerlink" title="Channel接受或者发送会造成阻塞的消息"></a>Channel接受或者发送会造成阻塞的消息</h3><p>当一个新的goroutine被创建时<br>可以造成阻塞的系统调用，如文件和网络操作<br>垃圾回收<br>下面让我们来看一下调度器具体是如何工作的。Golang调度器中有三个概念</p><ul><li>Processor（P）</li><li>OSThread（M）</li><li>Goroutines（G）</li></ul><p>在一个Go程序中，可用的线程数是通过GOMAXPROCS来设置的，默认值是可用的CPU核数。我们可以用runtime包动态改变这个值。OSThread调度在processor上，goroutines调度在OSThreads上<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2ml5ze1wj30hs08at98.jpg" srcset="/img/loading.gif" alt=""><br>Golang的调度器可以利用多processor资源，在任意时刻，M个goroutine需要被调度到N个OS threads上，同时这些threads运行在至多GOMAXPROCS个processor上（N &lt;= GOMAXPROCS）。Go scheduler将可运行的goroutines分配到多个运行在一个或多个processor上的OS threads上。</p><p>每个processor有一个本地goroutine队列。同时有一个全局的goroutine队列。每个OSThread都会被分配给一个processor。最多只能有GOMAXPROCS个processor，每个processor同时只能执行一个OSThread。Scheculer可以根据需要创建OSThread。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2mlz0si1j30hs08j74l.jpg" srcset="/img/loading.gif" alt=""><br>在每一轮调度中，scheduler找到一个可以运行的goroutine并执行直到其被阻塞,由此可见，操作系统的一个线程下可以并发执行上千个goroutine，每个goroutine所占用的资源和切换开销都很小，因此，goroutine是golang适合高并发场景的重要原因。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>golang</tag>
      
      <tag>goroutine</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac上配置Golang开发环境</title>
    <link href="/2020/03/13/Mac%E4%B8%8A%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/03/13/Mac%E4%B8%8A%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/13/JYRMzrxeKlLNp26.jpg" srcset="/img/loading.gif" alt="Golang"></p><blockquote><p><strong>📝本篇文章记录我本人在Mac上配置Go开发环境的笔记📒</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Go Source Code</a></li><li>Go是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 罗伯特·格瑞史莫，罗勃·派克及肯·汤普逊于2007年9月开始设计Go，稍后Ian Lance Taylor、Russ Cox加入项目。Go是基于Inferno操作系统所开发的。</li><li>Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行计算模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，[2]，但它也具有pipeline模型的特征，比如通道传输。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。与C++相比，Go并不包括如枚举、异常处理、继承、泛型、断言、虚函数等功能，但增加了 切片(Slice) 型、并发、管道、垃圾回收功能、接口等特性的语言级支持[2]。Go 2.0版本将支持泛型[7]，对于断言的存在，则持负面态度，同时也为自己不提供类型继承来辩护。不同于Java，Go原生提供了关联数组（也称为哈希表（Hashes）或字典（Dictionaries）），就像字符串类型一样。</li></ul><h2 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h2><ul><li><a href="https://go.dev/" target="_blank" rel="noopener">Go Dev</a></li><li>浏览器🔛打开上面👆链接下载官方安装包<br><img src="https://i.loli.net/2020/03/13/XosNZdnTVtr3auA.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-13_15-54-37.jpg"></li><li>下载的时候根据自己系统版本下载对应的安装包</li><li>下载完成之后双击安装包即可安装</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>我本人Mac是使用的<code>iTerm2 + Oh My Zsh + zsh</code>所以我只需要编辑我的<code>~/.zshrc</code>文件📃即可.</p><ul><li>通过vscode打开<pre><code class="bash">code ~/.zshrc</code></pre></li><li>在文件最后添加修改配置<pre><code class="bash">##go语言环境配置 ##go 语言安装主根目录export GOROOT=/usr/local/go#GOPATH是自己的go项目路径，自定义设置export GOPATH=/Users/ding/Documents/GO_CODE_DEV# 启用 Go Modules 功能export GO111MODULE=on# 配置 GOPROXY 环境变量 &amp; 国内网络环境大家都知道不多说export GOPROXY=https://goproxy.io,directexport PATH=$PATH:$GOBIN:$GOPATH/bin:GO111MODULE:GOPROXY</code></pre></li><li>然后使用<code>source ~/.zshrc</code>文件</li><li>在terminal里面输入<code>go env</code>即可查看环境<br><img src="https://i.loli.net/2020/03/13/3hrCzjTS5D4MlKJ.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-13_16-07-43.jpg"></li></ul><h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><p>我个人使用vscode比较多一点,Goland在开发大型项目才使用<br><strong>VS Code官方下载地址：<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a></strong><br>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。双击下载好的安装文件，双击安装即可。</p><ul><li><h4 id="安装Go语言开发工具包"><a href="#安装Go语言开发工具包" class="headerlink" title="安装Go语言开发工具包"></a>安装Go语言开发工具包</h4><p>在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。<br>Windows平台按下Ctrl+Shift+P，Mac平台按Command+Shift+P，这个时候VS Code界面会弹出一个输入框，如下图：<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535662106193.jpg" srcset="/img/loading.gif" alt="GO"><br>我们在这个输入框中输入<code>&gt;go:install</code>，下面会自动搜索相关命令，我们选择<code>Go:Install/Update Tools</code>这个命令<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535659707162.jpg" srcset="/img/loading.gif" alt="GOINSTALL"><br>选中并会回车执行该命令（或者使用鼠标点击该命令）<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535665573387.jpg" srcset="/img/loading.gif" alt="golang"></p></li><li><h4 id="配置代码片段快捷键"><a href="#配置代码片段快捷键" class="headerlink" title="配置代码片段快捷键"></a>配置代码片段快捷键</h4><p>还是按Ctrl/Command+Shift+P,按下图输入<code>&gt;snippets</code>，选择命令并执行<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535687503862.jpg" srcset="/img/loading.gif" alt="GO"><br>配置<code>snippets</code>代码片段模本<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535688890224.jpg" srcset="/img/loading.gif" alt="GO SNIPPETS"><br>大家可以简单看下上面的注释，介绍了主要用法：</p><pre><code class="json">    “这里放个名字”:{      &quot;prefix&quot;: &quot;这个是快捷键&quot;,      &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,      &quot;description&quot;: &quot;这里放提示信息的描述&quot;    }</code></pre><p> 其中<code>$0</code>表示最终光标提留的位置。举个例子，我这里创建了两个快捷方式，一个是输入<code>pln</code>就会在编辑器中插入<code>fmt.Println()</code>代码；输入<code>plf</code>，就会插入<code>fmt.Printf(&quot;&quot;)</code>代码。</p><pre><code class="json">  {    &quot;println&quot;:{      &quot;prefix&quot;: &quot;pln&quot;,      &quot;body&quot;:&quot;fmt.Println($0)&quot;,      &quot;description&quot;: &quot;println&quot;    },    &quot;printf&quot;:{      &quot;prefix&quot;: &quot;plf&quot;,      &quot;body&quot;: &quot;fmt.Printf(\&quot;$0\&quot;)&quot;,      &quot;description&quot;: &quot;printf&quot;    }  }</code></pre><p>添加如上配置后，保存。 我们打开一个go文件，测试一下效果：<br> <img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/demo1.gif" srcset="/img/loading.gif" alt="fmt.println"></p></li></ul><p><strong>好了配置完成,开始愉快的coding吧👨‍💻‍Good luck~😜</strong>   </p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Golang</tag>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo集成gitalk评论组件</title>
    <link href="/2020/03/08/Hexo%E9%9B%86%E6%88%90gitalk%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/03/08/Hexo%E9%9B%86%E6%88%90gitalk%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/BayMRX/Blog_source@master/img/hexo.jpg" srcset="/img/loading.gif" alt="hexo"></p><blockquote><p><strong>一个基于 Github Issue 和 Preact 开发的评论插件,下面我们就来使用gitalk来实现hexo的评论功能。</strong></p></blockquote><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk开源地址</a></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>使用 GitHub 登录</li><li>支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]</li><li>支持个人或组织</li><li>无干扰模式（设置 distractionFreeMode 为 true 开启）</li><li>快捷键提交评论 （cmd|ctrl + enter）</li></ul><p><a href="https://github.com/gitalk/gitalk/blob/master/readme.md" target="_blank" rel="noopener">Readme</a><br><a href="https://gitalk.github.io" target="_blank" rel="noopener">在线示例</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>两种方式</p><ul><li>直接引入</li></ul><pre><code class="html">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;  &lt;!-- or --&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>npm 安装</li></ul><pre><code class="sh">npm i --save gitalk</code></pre><pre><code class="js">import &#39;gitalk/dist/gitalk.css&#39;import Gitalk from &#39;gitalk&#39;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加一个容器：</p><pre><code class="html">&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</code></pre><p>用下面的 Javascript 代码来生成 gitalk 插件：</p><pre><code class="js">var gitalk = new Gitalk({  clientID: &#39;GitHub Application Client ID&#39;,  clientSecret: &#39;GitHub Application Client Secret&#39;,  repo: &#39;GitHub repo&#39;,  owner: &#39;GitHub repo owner&#39;,  admin: [&#39;GitHub repo owner and collaborators, only these guys can initialize github issues&#39;],  id: location.pathname,      // Ensure uniqueness and length less than 50  distractionFreeMode: false  // Facebook-like distraction free mode})gitalk.render(&#39;gitalk-container&#39;)</code></pre><p>需要 <strong>GitHub Application</strong>，如果没有 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击这里申请</a>，<code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p><p><strong>⚠️更多帮助在官方文档,可以在官方链接里查询。</strong></p><h2 id="设置GitHub"><a href="#设置GitHub" class="headerlink" title="设置GitHub"></a>设置GitHub</h2><ul><li>在个人设置里面创建一个Application<br><img src="https://i.loli.net/2020/03/08/fKqE9JHALBXMnN7.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-07_12-46-47.jpg"></li><li>然后我们需要的ClientID和Token<br><img src="https://i.loli.net/2020/03/08/vAx7wkRFhsNyqtX.jpg" srcset="/img/loading.gif" alt="clientId"></li><li>创建一个存放lssue仓库<br><img src="https://i.loli.net/2020/03/08/jeBmlY2RD6Fi35E.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-07_13-00-14.jpg"><h2 id="在Hexo里使用"><a href="#在Hexo里使用" class="headerlink" title="在Hexo里使用"></a>在Hexo里使用</h2><blockquote><p>这里我使用的主题里面已经集成了gitalk,所有我们直接修改配置文件就可以了。根据个人配置方法不同查询各种文档！！！</p></blockquote></li></ul><p>下面是我的配置文件📃</p><pre><code class="yaml"># Gitalk# You can get yout ClientID and ClientSecret from https://github.com/settings/applications/new# More info available at https://github.com/gitalk/gitalk#optionsgitalk:  clientID: 这里填写你之前application的clientID # GitHub Application Client ID  clientSecret: 之前申请的 # GitHub Application Client Secret  repo: ibyte.me # The repo to store comments  owner: deencode # GitHub repository owner. Can be personal user or organization.  admin: deencode # GitHub repo owner and collaborators, only these guys can initialize github issues, should be like &quot;[&#39;admin&#39;]&quot; or &quot;[&#39;admin1&#39;,&#39;admin2&#39;]&quot;  id: location.pathname # The unique id of the page. Length must less than 50.  language: zh-CN # Localization language key, en, zh-CN and zh-TW are currently available.  labels: &quot;[&#39;Gitalk&#39;]&quot; # GitHub issue labels.  perPage: 15 # Pagination size, with maximum 100.  pagerDirection: last # Comment sorting direction, available values are last and first.  distractionFreeMode: false # Facebook-like distraction free mode.  createIssueManually: true # By default, Gitalk will create a corresponding github issue for your every single page automatically when the logined user is belong to the admin users. You can create it manually by setting this option to true.</code></pre><p><strong>配置方法不同有所差异!!根据自己使用的插件查询官方文档进行的配置！！！Good Luck😜</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>gitalk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo搭建Blog</title>
    <link href="/2020/03/06/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BABlog/"/>
    <url>/2020/03/06/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BABlog/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/06/cOUwFstAaTeyGQk.jpg" srcset="/img/loading.gif" alt="Hexo&amp;GithubPage.jpg"></p><h3 id="1-相关网站"><a href="#1-相关网站" class="headerlink" title="1. 相关网站"></a>1. 相关网站</h3><ul><li>[Github]: <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></li><li>[Hexo]: <a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li><li>[Hexo Theme]: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>[Hexo Docs]: <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li></ul><h3 id="2-创建Github-Key"><a href="#2-创建Github-Key" class="headerlink" title="2. 创建Github Key"></a>2. 创建Github Key</h3><p>设置你的用户名称与邮件地址，如果是第一次使用git的话</p><pre><code class="bash">$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com</code></pre><p>使用ssh-keygen生成私钥和公钥<br>命令如下：</p><pre><code class="bash">$ ssh-keygen -t rsa</code></pre><p>然后到你GitHub 设置里面添加你刚才生成的xx.pub的内容到Key里面.</p><pre><code class="bash">$ ssh -T git@github.com</code></pre><p>登录Github，点击头像下的settings，添加ssh,新建一个new ssh key，将id_rsa.pub文件里的内容复制上去。</p><p>输入ssh -T <a href="mailto:git@github.com">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了。</p><p>这里你可以去创建一个public的仓库来存储等下Hexo相关的文件.</p><h3 id="3-安装NPM和Hexo"><a href="#3-安装NPM和Hexo" class="headerlink" title="3. 安装NPM和Hexo"></a>3. 安装NPM和Hexo</h3><ul><li>[NodeJS网站]: <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></li></ul><p>通过上面的网站下载对应的系统版本的NodeJS安装包.</p><ol><li><strong>设置NPM源到淘宝源</strong></li></ol><pre><code class="bash">   npm config set registry https://registry.npmjs.org/</code></pre><ol start="2"><li><p><strong>NPM安装HexoCli</strong></p><p>输入npm install hexo -g，开始安装Hexo</p></li></ol><pre><code class="bash">   npm install hexo -g</code></pre><ol start="3"><li><p><strong>初始化Hexo</strong></p><p>输入hexo -v，检查hexo是否安装成功</p><p>输入hexo init，初始化该文件夹（有点漫长的等待…）看到后面的“Start blogging with Hexo！”就说明初始化好了</p><p>输入npm install，安装所需要的组件</p></li></ol><pre><code class="bash">$ hexo -v$ hexo init$ hexo install        </code></pre><h3 id="4-配置config-yml文件"><a href="#4-配置config-yml文件" class="headerlink" title="4.配置config.yml文件"></a>4.配置config.yml文件</h3><p><strong>PS:这里根据自己需要自己配置，你可以去查询官方文档！！</strong></p><pre><code class="bash">deploy:  type: git  repo: git@github.com:Deencode/ibyte.me.git  branch: master</code></pre><h3 id="5-生成静态文件-amp-上传到GitHub仓库"><a href="#5-生成静态文件-amp-上传到GitHub仓库" class="headerlink" title="5.生成静态文件&amp;上传到GitHub仓库"></a>5.生成静态文件&amp;上传到GitHub仓库</h3><p><strong>🎉: 到了这一步就差不多了，运行下面命令就可以生成文件了.</strong></p><pre><code class="bash">#生成文件$ hexo generate#监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件#在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。$ hexo generate --watch# 本地运行$ hexo server#您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。$ hexo deploy</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
