<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图解各种限流算法</title>
    <link href="/2021/03/07/%E5%9B%BE%E8%A7%A3%E5%90%84%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/07/%E5%9B%BE%E8%A7%A3%E5%90%84%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前-言"><a href="#前-言" class="headerlink" title="前 言"></a>前 言</h2><blockquote><p>在开发高并发系统时，我们可能会遇到接口访问频次过高，为了保证系统的高可用和稳定性，这时候就需要做流量限制，你可能是用的 <code>Nginx</code> 这种 <code>Web Server</code> 来控制请求，也可能是用了一些流行的类库实现。限流是高并发系统的一大杀器，在设计限流算法之前我们先来了解一下它们是什么。</p></blockquote><h2 id="限-流"><a href="#限-流" class="headerlink" title="限 流"></a>限 流</h2><p><code>限流</code>的目的是通过对并发访问请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。通过对并发（或者一定时间窗口内）请求进行限速来保护系统，一旦达到限制速率则拒绝服务（定向到错误页或告知资源没有了）、排队等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据）。</p><p>如 图:</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn8bgfh0pzj30pt0ii4bx.jpg" srcset="/img/loading.gif" alt="自己魔改出来的漫画"></p><p>如图上的漫画，在某个时间段流量上来了，服务的接口访问频率可能会非常快，如果我们没有对接口访问频次做限制可能会导致服务器无法承受过高的压力挂掉，这时候也可能会产生数据丢失，所以就要对其进行限流处理。</p><p>限流算法就可以帮助我们去控制每个接口或程序的函数被调用频率，它有点儿像保险丝，防止系统因为超过访问频率或并发量而引起瘫痪。我们可能在调用某些第三方的接口的时候会看到类似这样的响应头：</p><pre><code class="yaml">X-RateLimit-Limit: 60         //每秒60次请求X-RateLimit-Remaining: 22     //当前还剩下多少次X-RateLimit-Reset: 1612184024 //限制重置时间</code></pre><p>上面的 <code>HTTP Response</code> 是通过响应头告诉调用方服务端的限流频次是怎样的，保证后端的接口访问上限。为了解决限流问题出现了很多的算法，它们都有不同的用途，通常的策略就是拒绝超出的请求，或者让超出的请求排队等待。</p><p><strong>一般来说，限流的常用处理手段有：</strong></p><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li>令牌桶</li></ul><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><blockquote><p>计数器是一种最简单限流算法，其原理就是：<code>在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。</code><br>这个就像你去坐车一样，车厢规定了多少个位置，满了就不让上车了，不然就是超载了，被交警叔叔抓到了就要罚款的，如果我们的系统那就不是罚款的事情了，可能直接崩掉了。</p></blockquote><ol><li>可以在程序中设置一个变量 <code>count</code>，当过来一个请求我就将这个数<code>+1</code>，同时记录请求时间。</li><li>当下一个请求来的时候判断 <code>count</code> 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 <code>1</code> 分钟内。</li><li>如果在 <code>1</code> 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。</li><li>如果该请求与第一个请求的间隔时间大于计数周期，且 <code>count</code> 值还在限流范围内，就重置 <code>count</code>。</li></ol><p>代码实现:</p><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;sync&quot;    &quot;time&quot;)type Counter struct {    rate  int           //计数周期内最多允许的请求数    begin time.Time     //计数开始时间    cycle time.Duration //计数周期    count int           //计数周期内累计收到的请求数    lock  sync.Mutex}func (l *Counter) Allow() bool {    l.lock.Lock()    defer l.lock.Unlock()    if l.count == l.rate-1 {        now := time.Now()        if now.Sub(l.begin) &gt;= l.cycle {            //速度允许范围内， 重置计数器            l.Reset(now)            return true        } else {            return false        }    } else {        //没有达到速率限制，计数加1        l.count++        return true    }}func (l *Counter) Set(r int, cycle time.Duration) {    l.rate = r    l.begin = time.Now()    l.cycle = cycle    l.count = 0}func (l *Counter) Reset(t time.Time) {    l.begin = t    l.count = 0}func main() {    var wg sync.WaitGroup    var lr Counter    lr.Set(3, time.Second) // 1s内最多请求3次    for i := 0; i &lt; 10; i++ {        wg.Add(1)        log.Println(&quot;创建请求:&quot;, i)        go func(i int) {          if lr.Allow() {              log.Println(&quot;响应请求:&quot;, i)          }          wg.Done()        }(i)        time.Sleep(200 * time.Millisecond)    }    wg.Wait()}</code></pre><p>OutPut:</p><pre><code class="shell">2021/02/01 21:16:12 创建请求: 02021/02/01 21:16:12 响应请求: 02021/02/01 21:16:12 创建请求: 12021/02/01 21:16:12 响应请求: 12021/02/01 21:16:12 创建请求: 22021/02/01 21:16:13 创建请求: 32021/02/01 21:16:13 创建请求: 42021/02/01 21:16:13 创建请求: 52021/02/01 21:16:13 响应请求: 52021/02/01 21:16:13 创建请求: 62021/02/01 21:16:13 响应请求: 62021/02/01 21:16:13 创建请求: 72021/02/01 21:16:13 响应请求: 72021/02/01 21:16:14 创建请求: 82021/02/01 21:16:14 创建请求: 9</code></pre><p>可以看到我们设置的是每<code>200ms</code>创建一个请求，明显高于<code>1</code>秒最多<code>3</code>个请求的限制，运行起来之后发现编号为 <code>2、3、4、8、9</code> 的请求被丢弃，说明限流成功。</p><p><strong>那么问题来了，如果有个需求对于某个接口 <code>/query</code> 每分钟最多允许访问 200 次，假设有个用户在第 59 秒的最后几毫秒瞬间发送 200 个请求，当 59 秒结束后 <code>Counter</code> 清零了，他在下一秒的时候又发送 200 个请求。那么在 1 秒钟内这个用户发送了 2 倍的请求，这个是符合我们的设计逻辑的，这也是计数器方法的设计缺陷，系统可能会承受恶意用户的大量请求，甚至击穿系统。</strong></p><p>如下图:</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmr45dwvpoj30om0eo75c.jpg" srcset="/img/loading.gif" alt="计数图解"></p><p>这种方法虽然简单，但也有个大问题就是没有很好的处理单位时间的边界。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><code>滑动窗口</code>是针对计数器存在的临界点缺陷，所谓 <code>滑动窗口（Sliding window）</code> 是一种流量控制技术，这个词出现在 <code>TCP</code> 协议中。<code>滑动窗口</code>把固定时间片进行划分，并且随着时间的流逝，进行移动，固定数量的可以移动的格子，进行计数并判断阀值。</p><p>如 图：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmr46n366gj30y80eota1.jpg" srcset="/img/loading.gif" alt="图解1"></p><p>上图中我们用红色的虚线代表一个时间窗口（<code>一分钟</code>），每个时间窗口有 <code>6</code> 个格子，每个格子是 <code>10</code> 秒钟。每过 <code>10</code> 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 <code>Counter</code>，假如一个请求在 <code>0:45</code> 访问了那么我们将第五个格子的计数器 <code>+1</code>（也是就是 <code>0:40~0:50</code>），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。</p><p>那么滑动窗口如何解决我们上面遇到的问题呢？来看下面的图：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmr47hbj6dj31cq0kwgpd.jpg" srcset="/img/loading.gif" alt="图解2"></p><p>当用户在<code>0:59</code> 秒钟发送了 <code>200</code>个请求就会被第六个格子的计数器记录 <code>+200</code>，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 <code>200</code> 个请求，所以再发送的话就会触发限流，则拒绝新的请求。</p><p>其实计数器就是滑动窗口啊，只不过只有一个格子而已，所以想让限流做的更精确只需要划分更多的格子就可以了，为了更精确我们也不知道到底该设置多少个格子，<code>格子的数量影响着滑动窗口算法的精度，依然有时间片的概念，无法根本解决临界点问题</code>。</p><ul><li>相关算法实现 <a href="github.com/RussellLuo/slidingwindow">github.com/RussellLuo/slidingwindow</a></li></ul><h2 id="漏-桶"><a href="#漏-桶" class="headerlink" title="漏 桶"></a>漏 桶</h2><p><code>漏桶算法（Leaky Bucket）</code>，原理就是一个固定容量的漏桶，按照固定速率流出水滴。用过水龙头都知道，打开龙头开关水就会流下滴到水桶里，而漏桶指的是水桶下面有个漏洞可以出水。如果水龙头开的特别大那么水流速就会过大，这样就可能导致水桶的水满了然后溢出。</p><p>如 图：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmr4ascdhrj30cb08bq37.jpg" srcset="/img/loading.gif" alt="漏 桶"></p><p>一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率（<code>处理速度</code>），从而达到 <code>流量整形</code> 和 <code>流量控制</code> 的效果。</p><p>代码实现:</p><pre><code class="go">type LeakyBucket struct {    rate       float64 //固定每秒出水速率    capacity   float64 //桶的容量    water      float64 //桶中当前水量    lastLeakMs int64   //桶上次漏水时间戳 ms    lock sync.Mutex}func (l *LeakyBucket) Allow() bool {    l.lock.Lock()    defer l.lock.Unlock()    now := time.Now().UnixNano() / 1e6    eclipse := float64((now - l.lastLeakMs)) * l.rate / 1000 //先执行漏水    l.water = l.water - eclipse                              //计算剩余水量    l.water = math.Max(0, l.water)                           //桶干了    l.lastLeakMs = now    if (l.water + 1) &lt; l.capacity {        // 尝试加水,并且水还未满        l.water++        return true    } else {        // 水满，拒绝加水        return false    }}func (l *LeakyBucket) Set(r, c float64) {    l.rate = r    l.capacity = c    l.water = 0    l.lastLeakMs = time.Now().UnixNano() / 1e6}</code></pre><p>漏桶算法有以下特点：</p><ul><li>漏桶具有固定容量，出水速率是固定常量（流出请求）</li><li>如果桶是空的，则不需流出水滴</li><li>可以以任意速率流入水滴到漏桶（流入请求）</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）</li></ul><p>漏桶限制的是常量流出速率（即流出速率是一个固定常量值），所以最大的速率就是出水的速率，不能出现突发流量。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法<code>（Token Bucket）</code>是网络流量整形<code>（Traffic Shaping）</code>和速率限制<code>（Rate Limiting）</code>中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmr4cwnxkmj30bq07iwet.jpg" srcset="/img/loading.gif" alt="令牌桶算法"></p><p>我们有一个固定的桶，桶里存放着令牌<code>（token）</code>。一开始桶是空的，系统按固定的时间<code>（rate）</code>往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。当请求来的时候，从桶里移除一个令牌，如果桶是空的则拒绝请求或者阻塞。</p><p>实现代码：</p><pre><code class="go">type TokenBucket struct {    rate         int64 //固定的token放入速率, r/s    capacity     int64 //桶的容量    tokens       int64 //桶中当前token数量    lastTokenSec int64 //桶上次放token的时间戳 s    lock sync.Mutex}func (l *TokenBucket) Allow() bool {    l.lock.Lock()    defer l.lock.Unlock()    now := time.Now().Unix()    l.tokens = l.tokens + (now-l.lastTokenSec)*l.rate // 先添加令牌    if l.tokens &gt; l.capacity {        l.tokens = l.capacity    }    l.lastTokenSec = now    if l.tokens &gt; 0 {        // 还有令牌，领取令牌        l.tokens--        return true    } else {        // 没有令牌,则拒绝        return false    }}func (l *TokenBucket) Set(r, c int64) {    l.rate = r    l.capacity = c    l.tokens = 0    l.lastTokenSec = time.Now().Unix()}</code></pre><p>令牌桶有以下特点：</p><ul><li>令牌按固定的速率被放入令牌桶中</li><li>桶中最多存放 <code>B</code> 个令牌，当桶满时，新添加的令牌被丢弃或拒绝</li><li>如果桶中的令牌不足 <code>N</code> 个，则不会删除令牌，且请求将被限流（丢弃或阻塞等待）</li></ul><p>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌…），并允许一定程度突发流量。</p><h2 id="小-结"><a href="#小-结" class="headerlink" title="小 结"></a>小 结</h2><p>目前常用的是<code>令牌桶</code>这种，本文介绍了几种常见的限流算法实现，文章撰写不易，点个关注不迷路。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么实现一个搜索引擎</title>
    <link href="/2021/03/07/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    <url>/2021/03/07/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goajgn7ah4j30vq0hsjy7.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="概-述"><a href="#概-述" class="headerlink" title="概 述"></a>概 述</h2><blockquote><p>在这个信息爆炸的时代里，我们平时想要去找一些自己感兴趣的东西通常都是通过<code>搜索引擎</code>来帮你完成查找的。用过搜索引擎的人都知道，我们在搜索栏中输入我们需要的查找的<code>关键字</code>，点击<code>搜索</code>就会得到一个结果页面，这个结果页面的内容就包含了我们要查找的<code>关键字</code>。<br>那么<code>搜索引擎</code>到底是如何高效查找目标内容呢？本文主要介绍<code>搜索引擎</code>的一些实现的相关技术。</p></blockquote><h2 id="怎么从文章里面找到你需要的内容？"><a href="#怎么从文章里面找到你需要的内容？" class="headerlink" title="怎么从文章里面找到你需要的内容？"></a>怎么从文章里面找到你需要的内容？</h2><p>那么第一个问题来了，我们在<code>搜索框</code>里面输入一大堆信息，搜索引擎是怎么找到我需要的内容的呢？？这个问题我认为有一定基础的人都可以实现出来，也有很多人讨论怎么实现效率更高，那我们就先看看我们的请求过程：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goakdpabrjj30rf03v3yr.jpg" srcset="/img/loading.gif" alt="查询过程"></p><p>当然这里是简单的画了一下，具体看各自业务情况。</p><h2 id="分词处理"><a href="#分词处理" class="headerlink" title="分词处理"></a>分词处理</h2><p>假设我们在<code>搜索框</code>输入了一些搜索关键字，那是搜索引擎在后端会对我们的输入的关键字或者关键词进行分词处理。假设我们现在搜索一句话<code>I Love You!</code>那这段话通过分词之后就是<code>[I,Love,You,I Love You]</code>，当然这是英文输入的时候会带上空格，如果是中文的话需要借助一些专业的分词算法库进行分词操作，这里不细说。</p><p><strong>相关的算法</strong></p><ul><li>前缀词典实现高效的词图扫描，生成句子中汉字所有可能出现成词情况所构成的有向无环图（<code>DAG</code>）</li><li>采用动态规划查找最大概率路径，找出基于词频最大切分组合</li><li>对于未登录词，采用汉字成词能力的<code>HMM模型</code>，采用<code>Viterbi算法</code>计算</li><li>基于<code>Viterbi算法</code>做词性标注</li><li>基于<code>TF-IDF</code>和<code>TextRank模型</code>抽取关键词</li></ul><h2 id="数据太多了，怎么查找？"><a href="#数据太多了，怎么查找？" class="headerlink" title="数据太多了，怎么查找？"></a>数据太多了，怎么查找？</h2><p>假设我们服务器包含1000篇文章，我们要在这些文章文件里面找到包含有<code>xxx</code>的内容，如果从头开始遍历文件内容然后对匹配的做个记录和收集返回，读取一篇文章所消耗的时间假定为50毫秒，每篇文章搜索消耗0.1毫秒，那这样是不是太浪费服务器资源了！！</p><p>经过简单的推算会明显发现，这个搜索的速度是完全不可能接受的，人家<code>google</code>，<code>sogo</code>可都是几百毫秒取出上亿的列表所以，上述的方法完全行不通，我们需要新的方法。</p><h2 id="倒排索引-该上场了"><a href="#倒排索引-该上场了" class="headerlink" title="倒排索引 该上场了"></a><code>倒排索引</code> 该上场了</h2><blockquote><p><code>倒排索引</code>（<code>英文：Inverted Index</code>），是一种索引方法，常被用于全文检索系统中的一种<code>单词文档映射结构</code>。现代搜索引擎绝大多数的索引都是基于倒排索引来进行构建的。我们在使用搜索引擎查找信息时往往只输入信息中的某个属性关键字，如一些用户不记得歌名，会输入歌词来查找歌名，输入某个节目内容片段来查找该节目等等。</p></blockquote><p><code>倒排索引</code>是<code>关键词——文档</code>形式的一种映射结构，实现了通过物品属性信息对物品进行映射时，可以帮助用户快速定位到目标信息，从而极大降低了信息获取难度。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goamak8fytj309q09qwf0.jpg" srcset="/img/loading.gif" alt=""></p><p>相信大家都使用👆这个，字典的目录和侧面都做了一些特殊标记，方便我们更快查找到某些内容。<code>倒排索引</code>也是这样的对源数据的内容进行特殊的处理把里面的信息做一个索引记录。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goamle0eltj30i10d80ur.jpg" srcset="/img/loading.gif" alt="倒排索引图"></p><p>一般地，当接受到用户查询请求时，进入到倒排索引进行检索时，在返回结果的过程中，主要有以下几个步骤：</p><ul><li>在分词系统对用户请求等原始<code>Query</code>进行分析，产生对应的<code>terms</code>；</li><li><code>terms</code>在倒排索引中的词项列表中查找对应的<code>terms</code>的结果列表；</li><li>对结果列表数据进行微运算，如：计算文档静态分，文档相关性等；</li><li>基于上述运算得分对文档进行综合排序，最后返回结果给用户。</li></ul><p>构建倒排索引是搜索引擎里面至关重要的一个步骤。从技术层面去分析，对于构造一个倒排索引，主要分为两部分：</p><ul><li>Doc2term词项构造</li><li>倒排记录表的构建</li></ul><h2 id="词项构造"><a href="#词项构造" class="headerlink" title="词项构造"></a>词项构造</h2><p><code>词项构造</code>是在构建索引过程中必不可或缺的一个步骤，词项构造效果的好坏往往会直接影响到用户的搜索体验，以及搜索结果的召回。该过程主要是利用分词系统将文档中的各项属性的文本信息拆分成一些表意较强且重要的词汇，便于用户查找。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goan3ri2onj30mx0epab6.jpg" srcset="/img/loading.gif" alt=""></p><p>例如问题：</p><ul><li>重音及变音符号问题</li><li>大小写转换问题</li><li>中文多音字问题</li><li>美式英语问题</li></ul><p>一个简单的解决方案：我们对匹配的词语进行统计，引用次数越多，那么匹配度越高，可以认为越准确。</p><h2 id="小-结"><a href="#小-结" class="headerlink" title="小 结"></a>小 结</h2><p>本文介绍的只是简单的全文搜索实现及原理，如果要做专业级的搜索引擎，这些知识是完全不够的。你需要知道爬虫，自然语言分析处理，怎么提高搜索处理的速度等等，海量数据的存储等等知识。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的WebAssembly应用</title>
    <link href="/2021/01/07/Go%E7%9A%84WebAssembly%E5%BA%94%E7%94%A8/"/>
    <url>/2021/01/07/Go%E7%9A%84WebAssembly%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmfcr3hkdjj31mx0u07oa.jpg" srcset="/img/loading.gif" alt="Go WebAssembly"></p><h2 id="介-绍"><a href="#介-绍" class="headerlink" title="介 绍"></a>介 绍</h2><p>  在 go 1.11 的时候 go 官方向 go 实验性的添加了 WebAssembly 支持，也就是说 golang 可以编译 为 wasm 以供 JavaScript 进行调用。</p><p>在这里我想说一下我的感受，在编写代码时应该是主要编写 go 的代码供 JavaScript 调用 而不是在 在 go 中调用 JavaScript 代码。</p><p>目前 go 还只是实验性的支持 wasm 以后可能会变更，后面我会尽量跟进。</p><p>另外如果感兴趣的话，推荐一本柴树杉、丁尔男两位大佬的《<code>WebAssembly 标准入门</code>》，估计也快发售了。</p><h2 id="WebAssembly-简介"><a href="#WebAssembly-简介" class="headerlink" title="WebAssembly 简介"></a>WebAssembly 简介</h2><blockquote><p><a href="https://webassembly.org/" target="_blank" rel="noopener" title="WebAssembly">WebAssembly</a> 是一种新兴的网页虚拟机标准，它的设计目标包括高可移植性、高安全性、高效率（包括载入效率和运行效率）、尽可能小的程序体积，WebAssembly 程序在 JavaScript 环境下的使用方法、WebAssembly 汇编语言和二进制格式。另外WebAssembly有好几个干爹:万维网联盟、 Mozilla、微软、谷歌、 苹果。</p></blockquote><h2 id="Hello-Wasm"><a href="#Hello-Wasm" class="headerlink" title="Hello Wasm"></a>Hello Wasm</h2><p>由于目前只是实验性的支持，在编写代码时 引用 <code>syscall/js</code> 会爆红 需要在<code>goland</code>中将变量环境 指定为 <code>OS=js ARCH=wasm goland</code> 的设置在 <code>seting -&gt; Go -&gt; Build Tags &amp;&amp; Vendoring</code> 中进行更改。</p><p>浏览器 我使用的是 chrome 包括 js 部分演示我也是在 chrome 下进行。</p><ol><li>创建一个项目 <code>hello-wasm-go</code></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmf71jtq1tj30tn0krn1p.jpg" srcset="/img/loading.gif" alt="hello-wasm-go"></p><ol start="2"><li>创建 main.go 并写入以下内容</li></ol><pre><code>package mainimport &quot;fmt&quot;func main() {    fmt.Println(&quot;Hello, WebAssembly!&quot;)}</code></pre><ol start="3"><li>然后将 main.go 编译为 main.wasm</li></ol><pre><code class="bash">GOOS=js GOARCH=wasm go build -o main.wasm</code></pre><ol start="4"><li>创建 index.html 并写入以下内容</li></ol><pre><code class="go">&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;    const go = new Go();    WebAssembly.instantiateStreaming(fetch(&quot;main.wasm&quot;), go.importObject).then((result) =&gt; {        go.run(result.instance);    });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="5"><li>将 JavaScript 支持文件移动到本目录</li></ol><pre><code class="bash">cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; .</code></pre><p>下载 go 版的 简单 web 服务器</p><pre><code class="bash">go get -v -u github.com/shurcooL/goexec</code></pre><p>然后运行它</p><pre><code class="bash">goexec &#39;http.ListenAndServe(`:8080`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><p>然后打开 chrome 访问 <code>http://127.0.0.1:8080/</code> 并按下 F12 打开 DevTools 不出意外的话你应该会看到 控制台上输出 <code>Hello, WebAssembly!</code></p><p>接下来就正式开始了，在每次更改 go 代码时 你需要对 go 代码进行重新编译，重启 <code>goexec</code> 并对网页进行刷新。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmf7ft33buj31470mtdjt.jpg" srcset="/img/loading.gif" alt="GoWebAssembly"></p><h2 id="在js里面调用go的wasm"><a href="#在js里面调用go的wasm" class="headerlink" title="在js里面调用go的wasm"></a>在js里面调用go的wasm</h2><p>接下来我们玩一点不一样的，go 调用 JavaScript 函数并且回显到前端页面，也就是在前端调用我们使用go写的代码逻辑。</p><ol><li>首先我们创建一个<code>main.go</code>和<code>index.html</code></li></ol><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2021/1/7 - 4:26 下午 - UTC/GMT+08:00package mainimport (    &quot;fmt&quot;    &quot;syscall/js&quot;)// 通过Go代码操作页面dom节点var (    document = js.Global().Get(&quot;document&quot;)    nameEle  = document.Call(&quot;getElementById&quot;, &quot;name&quot;)    helloEle = document.Call(&quot;getElementById&quot;, &quot;hello&quot;)    btnEle   = js.Global().Get(&quot;btn&quot;))func sayHello(this js.Value, args []js.Value) interface{} {    name := nameEle.Get(&quot;value&quot;).String()    if len(name) == 0 {        name = &quot;github.com/higker/hello-wasm-go&quot;    }    str := fmt.Sprintf(&quot;Hello,%s&quot;, name)    helloEle.Set(&quot;innerHTML&quot;, js.ValueOf(str))    return nil}func main() {    done := make(chan int, 0)    btnEle.Call(&quot;addEventListener&quot;, &quot;click&quot;, js.FuncOf(sayHello))    &lt;-done}</code></pre><p>下面是index.html内容</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Hello WebAssembly For Golang&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;    &lt;p&gt;You Name:&lt;/p&gt;    &lt;input id=&quot;name&quot; type=&quot;text&quot;&gt;    &lt;button id=&quot;btn&quot;&gt;Running&lt;/button&gt;    &lt;h1 id=&quot;hello&quot;&gt;&lt;/h1&gt;&lt;/body&gt;&lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    const go = new Go();    WebAssembly.instantiateStreaming(fetch(&quot;main.wasm&quot;), go.importObject).then((result) =&gt; {        go.run(result.instance);    });&lt;/script&gt;&lt;/html&gt;</code></pre><ol start="2"><li><p>编译代码 <code>GOOS=js GOARCH=wasm go build -o main.wasm</code></p></li><li><p>复制依赖文件<code>cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; .</code></p></li><li><p>启动静态服务器 </p></li></ol><pre><code class="bash">goexec &#39;http.ListenAndServe(`:8080`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><ol start="5"><li>你也可以通过其他方式启动一个服务器来浏览。</li></ol><h3 id="效-果👍"><a href="#效-果👍" class="headerlink" title="效 果👍"></a>效 果👍</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmghf9sijmj30p80lw419.jpg" srcset="/img/loading.gif" alt="运行效果"></p><h2 id="相关函数解析"><a href="#相关函数解析" class="headerlink" title="相关函数解析"></a>相关函数解析</h2><ul><li>通过 <code>js.Global().Get(&quot;btn&quot;)</code> 或 <code>document.Call(&quot;getElementById&quot;, &quot;hello&quot;)</code>两种方式获取到 DOM 元素。</li><li>btnEle 调用 <code>addEventListener</code> 为 btn 绑定点击事件 <code>sayHello</code>。</li><li>helloEle 调用 <code>Set(&quot;innerHTML&quot;, ...)</code> 渲染计算结果。</li><li>JavaScript代码中<code>WebAssembly.instantiateStreaming(....)</code>是加载我们go代码编译的wasm文件，然后网页就具备我们刚才使用go写的功能了。</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmffesitljj30os04iq3e.jpg" srcset="/img/loading.gif" alt="WebAssembly生命周期"></p><h2 id="在go里面调用其他语言的wasm"><a href="#在go里面调用其他语言的wasm" class="headerlink" title="在go里面调用其他语言的wasm"></a>在go里面调用其他语言的wasm</h2><p><strong>通过上面的例子可以看出来，我们写的go代码可以编译成wasm扔给浏览器执行我们的逻辑，反之我们也可以通过go来操作其他语言编译的wasm文件，并且调用里面的函数。</strong></p><ol><li>首先我们需要安装一个依赖库</li><li>然后我们开启cgo</li><li>然后把我们准备一个tests.wasm文件<pre><code class="bash"># Enable cgo 启动cgoexport CGO_ENABLED=1; export CC=gcc;# 拉取我们需要的解析库github.com/wasmerio/go-ext-wasm</code></pre><blockquote><p>注意这里有一个坑，官方那个github主页是让你去下载<code>go get github.com/wasmerio/wasmer-go</code>，其实目前不是这个了，我感觉是那个老外故意阻挡我们gopher去学习wasm的步伐，想让我们直接入坑rust，啊哈哈哈，开个玩笑拉，✅正确方式去下载这个包<code>github.com/wasmerio/go-ext-wasm/wasmer</code>，不过在你们的看到这个文章的时候我已经发起pr请求准备修复这个坑，啊哈哈</p></blockquote></li></ol><p><em>项目官方地址</em><a href="https://github.com/wasmerio/wasmer-go" target="_blank" rel="noopener">https://github.com/wasmerio/wasmer-go</a></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgj0b3w5gj30q00egwg9.jpg" srcset="/img/loading.gif" alt="操作步骤截图"></p><ol start="4"><li>然后在我们的<code>main.go</code>文件中写入</li></ol><pre><code class="go">package mainimport (    &quot;fmt&quot;    wasm &quot;github.com/wasmerio/go-ext-wasm/wasmer&quot;)func main() {    // 将WebAssembly模块读取为字节    bytes, _ := wasm.ReadBytes(&quot;tests.wasm&quot;)    // 实例化WebAssembly模块    instance, _ := wasm.NewInstance(bytes)    defer instance.Close()    // 从WebAssembly实例获取`sum`导出的函数。    sum := instance.Exports[&quot;sum&quot;]    // 用Go标准值调用导出的函数。WebAssembly    // 推断类型，并自动转换值    result, _ := sum(11, 11)    // 结果    fmt.Println(result) // 22!}</code></pre><ol start="5"><li>执行<pre><code class="bash">$/Desktop/hello-wasm-go/rand_wasm:$ go run main.go 22</code></pre></li></ol><h2 id="小-结"><a href="#小-结" class="headerlink" title="小 结"></a>小 结</h2><p>从上面的例子我们可以看出来，wasm应用案例不止于此，例如很多第三方的发送短信的API接口SDK都是不同语言版本的代码实现，如果换成wasm，直接写一套代码编译成wasm，提供一个函数，其他语言加载这个wasm文件就可以了，只需要一个wasm解决了…..</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="http://github.com/higker/hello-wasm-go" target="_blank" rel="noopener">http://github.com/higker/hello-wasm-go</a></li><li><a href="https://golang.org/pkg/syscall/js" target="_blank" rel="noopener">https://golang.org/pkg/syscall/js</a></li><li><a href="https://github.com/golang/go/wiki/WebAssembly" target="_blank" rel="noopener">https://github.com/golang/go/wiki/WebAssembly</a></li></ul><h3 id="Javascript的API文档"><a href="#Javascript的API文档" class="headerlink" title="Javascript的API文档"></a>Javascript的API文档</h3><ul><li><a href="https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/webassembly/instantiatestreaming" target="_blank" rel="noopener">https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/webassembly/instantiatestreaming</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>webassembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员都应该懂的排序算法</title>
    <link href="/2020/11/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E6%87%82%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>作为一个程序员在谈到<code>算法</code>这个词的时候，第一反应就是那些令人头疼的LeetCode题目，那本片文章我们就讲讲程序员几个基础排序算法。</strong></p><ul><li>冒泡排序</li><li>选择排序</li><li>选择排序</li><li>希尔排序</li><li>快速排序</li><li>归并排序</li></ul><p><strong>复杂度对比图</strong><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" srcset="/img/loading.gif" alt="算法复杂度"></p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><ul><li>对无序数列进行安装每2个相邻数为一组的比较。</li><li>如果每相邻的2个数,左边比右边大 <code>left &gt; right</code>就交换的位置。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><strong>动图解析</strong><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" srcset="/img/loading.gif" alt="bubble sort"></p><p><strong>代码实现</strong></p><pre><code class="go">func Bubble(arr []int) {    for i := 0; i &lt; len(arr); i++ {        // 冒泡是每次相邻的2个元素排        for j := 0; j &lt; len(arr)-1-i; j++ {            if arr[j] &gt; arr[j+1] {                arr[j], arr[j+1] = arr[j+1], arr[j]            }        }    }}</code></pre><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><p><strong>动图解析</strong><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" srcset="/img/loading.gif" alt="selection sort"></p><p><strong>代码实现</strong></p><pre><code class="go">// 选择排序 O(n^2)func Selection(arr []int) {    // 这里的减一是因为需要通过下标方法元素 元素下标是从0开始的    // 假设mid是最小值，然后和后面元素进行比较    // 如果发现有比mid小的元素，就更新mid坐标    for i := 0; i &lt; len(arr)-1; i++ {        min := i        for j := i + 1; j &lt; len(arr); j++ {            if arr[min] &gt; arr[j] {                min = j            }        }        // 一轮结束之后交换2个元素位置        arr[i], arr[min] = arr[min], arr[i]    }}</code></pre><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><ul><li>将无序数列看成一个有序数列(范围是第一个元素)和无序数列(范围就是第二元素到末尾元素)。</li><li>然后从头到尾扫描无序数列，把扫描到的元素插入到有序数列的适当位置。</li><li>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</li></ul><p><strong>动图解析</strong><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" srcset="/img/loading.gif" alt="insertion sort"></p><p><strong>代码实现</strong></p><pre><code class="go">func Insertion(numbers []int) {    for i := 1; i &lt; len(numbers); i++ {        pervIndex := i - 1        current := numbers[i]        // 用上一个元素比较当前的元素        for pervIndex &gt;= 0 &amp;&amp; numbers[pervIndex] &gt; current {            numbers[pervIndex+1] = numbers[pervIndex]            // 向左移动方便下次比较            pervIndex -= 1        }        // 如果pervIndex没有变化说明就不需要操作        if pervIndex+1 != i {            numbers[pervIndex+1] = current        }    }}</code></pre><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><ul><li>希尔排序属于缩小增量排序。</li><li>将数据区分成特定间隔的几个小区块。</li><li>每排完一轮数据渐进式变成有序的。</li><li>以插入排序法排完区块内的数据后再渐渐减少间隔的距离。</li></ul><p><strong>动图解析</strong><br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkh1hyq8a5g30qi0exkc0.gif" srcset="/img/loading.gif" alt="shell sort"></p><p><strong>代码实现</strong></p><pre><code class="go">// 希尔排序 O(n log n)func Shell(arr []int) {    var pervIndex, current int    // 1.先把原数据安装自定义步长分组    for gap := len(arr) / 2; gap &gt; 0; gap /= 2 {        // 2.然后分好组的数据进行选择排序        for i := gap; i &lt; len(arr); i++ {            // 希尔排序            pervIndex = i - gap            current = arr[i]            for pervIndex &gt;= 0 &amp;&amp; arr[pervIndex] &gt; current {                arr[pervIndex+gap] = arr[pervIndex]                pervIndex -= gap            }            if pervIndex+gap != i {                arr[pervIndex+gap] = current            }        }    }}</code></pre><h2 id="5-递归函数"><a href="#5-递归函数" class="headerlink" title="5. 递归函数"></a>5. 递归函数</h2><ul><li>递归函数就是在函数里面调用自己。</li><li>下面就是一个阶乘例子</li></ul><pre><code class="go">// https://zh.wikipedia.org/wiki/%E9%9A%8E%E4%B9%98func factorial(n int) int {    if n == 1 {        return 1    }    return n * factorial(n-1)}</code></pre><h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h2><ul><li>该算法是采用<code>分治法（Divide and Conquer）</code>的一个非常典型的应用。</li><li>先将一个无序数列进行分组。</li><li>然后子组也进行分组。</li><li>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</li></ul><p><strong>动图解析</strong><br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj9pvmv9wj31170qlh0x.jpg" srcset="/img/loading.gif" alt="merge sort"></p><p><strong>1.代码实现</strong></p><pre><code class="java">package me.ibyte.algorithm.sort;import me.ibyte.algorithm.Sort;import java.util.Arrays;// Go写多了换Java写一些 思路和逻辑是一样的public class MergeSort implements Sort {    public Integer[] sort(Integer[] arr) {        // 取到中轴 分组        int middle = arr.length / 2;        if (arr.length &lt; 2) {            return arr;        }        // 通过中轴分左右组        Integer[] left = Arrays.copyOfRange(arr, 0, middle);        Integer[] right = Arrays.copyOfRange(arr, middle, arr.length);        // 重复分组 直到不能分组为止并且进行小块归并排序        return merge(sort(left), sort(right));    }    private Integer[] merge(Integer[] left, Integer[] right) {        // 存放排序好的零时数组        Integer[] result = new Integer[left.length + right.length];        int i = 0;        // 不为空就进行排序        while (left.length != 0 &amp;&amp; right.length != 0) {            if (left[0] &lt;= right[0]) {                result[i++] = left[0];                // 排好的就减去                left = Arrays.copyOfRange(left, 1, left.length);            } else {                result[i++] = right[0];                right = Arrays.copyOfRange(right, 1, right.length);            }        }        // 检测剩下的        while (left.length != 0) {            result[i++] = left[0];            left = Arrays.copyOfRange(left, 1, left.length);        }        while (right.length != 0) {            result[i++] = right[0];            right = Arrays.copyOfRange(right, 1, right.length);        }        return result;    }}</code></pre><p><strong>源代码查看地址<a href="https://github.com/higker/java-algorithm/blob/main/src/main/java/me/ibyte/algorithm/sort/MergeSort.java" target="_blank" rel="noopener">源代码</a></strong></p><p><strong>2.Golang实现就想尝试一下go特性高阶函数</strong></p><pre><code class="go">func mergeSort(arr []int) []int {    var result []int    if len(arr) &lt; 2 {        return arr    }    middle := len(arr) / 2    // 注意这是切片 切取的时候是包左 不包右    left := arr[:middle]    right := arr[middle:]    return func(left, right []int) []int {        // 分组不能保证左右各组数据个数是一样的        for len(left) != 0 &amp;&amp; len(right) != 0 {            if left[0] &lt;= right[0] {                result = append(result, left[0])                left = left[1:]            } else {                result = append(result, right[0])                right = right[1:]            }        }        for len(left) != 0 {            result = append(result, left[0])            // 不断减小剩下的            left = left[1:]        }        for len(right) != 0 {            result = append(result, right[0])            right = right[1:]        }        return result    }(mergeSort(left), mergeSort(right))}</code></pre><h2 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7. 快速排序"></a>7. 快速排序</h2><ul><li>该算法是采用<code>分治法（Divide and Conquer）</code>的一个非常典型的应用。</li><li>从数列中挑出来一个元素作为基准<code>pivot</code>。</li><li>重新排序数列,所有元素比基准值小的摆放在基准前面,所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)，在这个分区退出之后,该基准就处于数列的中间位置，这个称为分区<code>(partition)</code>操作。</li><li>递归地<code>(recursive)</code>把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><strong>视频解析</strong></p><iframe src="//player.bilibili.com/player.html?aid=62621532&bvid=BV1at411T75o&cid=108813206&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:600px;hight:400px" > </iframe><p><strong>代码实现</strong></p><pre><code class="java">package me.ibyte.algorithm.sort;import me.ibyte.algorithm.Sort;// https://www.bilibili.com/video/BV1at411T75o?zwpublic class QuickSort implements Sort {    @Override    public Integer[] sort(Integer[] arr) {        return quickSort(arr,0,arr.length-1);    }    private  Integer[] quickSort(Integer[] arr, int left, int right) {        if (left &gt;= right) {            return arr;        }        // L记录开始位置 R记录尾巴位置        int pivot = arr[left],L=left,R=right;        while(left &lt; right){            while (left &lt; right &amp;&amp; arr[right] &gt;= pivot){                right--;            }            arr[left] = arr[right];            while(left &lt; right &amp;&amp; arr[left] &lt;= pivot){                left++;            }            arr[right] = arr[left];        }        arr[left] = pivot;        // L =0 left = 是中心轴值的位置 -1 分左右作用        quickSort(arr,L,left-1);        quickSort(arr,left+1,R);        return  arr;    }}</code></pre><h2 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h2><p><strong>根据个人电脑配置不同耗时不同！！!</strong><br><strong>处理器: 2.3 GHz 双核Intel Core i5</strong><br><strong>内 存:8 GB 2133 MHz LPDDR3</strong><br><strong>随机数据范围是:<code>rand.Intn(99999) - 9999)</code></strong><br><strong>测试过程中包含了随机数生成逻辑代码，所有算法速度应该减去随机数生成耗时（实际时间应该更短）。</strong></p><table><thead><tr><th>算法</th><th>数量积</th><th>时间</th></tr></thead><tbody><tr><td>冒泡</td><td>10万</td><td>14.118 seconds</td></tr><tr><td>选择</td><td>10万</td><td>8.862 seconds</td></tr><tr><td>插入</td><td>10万</td><td>1.69 seconds</td></tr><tr><td>希尔</td><td>10万</td><td>0.25 seconds</td></tr><tr><td>希尔</td><td>100万</td><td>0.509 seconds</td></tr><tr><td>希尔</td><td>1000万</td><td>3.314 seconds</td></tr><tr><td>希尔</td><td>1亿</td><td>46s 左右(5次重复测试结果)</td></tr><tr><td>归并</td><td>100万</td><td>0.752 seconds</td></tr><tr><td>快速</td><td>100万</td><td>0.109 seconds</td></tr></tbody></table><p><strong>测试源代码链接<a href="https://github.com/higker/go-algorithm/blob/master/sort.go" target="_blank" rel="noopener">查看源代码</a>,别忘了<code>star</code>😯。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>sort</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis那些事随笔</title>
    <link href="/2020/08/04/Redis%E9%82%A3%E4%BA%9B%E4%BA%8B%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/08/04/Redis%E9%82%A3%E4%BA%9B%E4%BA%8B%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghew9a67sqj30jg07bt8y.jpg" srcset="/img/loading.gif" alt=""></p><p><strong><code>Redis</code>（<code>Remote Dictionary Server</code>)，即<code>远程字典服务</code>，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<code>Key-Value数据库</code>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</strong></p><blockquote><p>随着时代的发展，现在用户对应用网络响应速度有较高的响应时间要求，而且数据和用户量很多，使用传统的方式很满足这些条件。服务器架构也在从单体应用变成多台服务器的分布式架构，从而出现了一些数据同步….一系列的问题，<code>redis</code>就是一个基于内存来存储数据的NOSQl数据库，它比传统的关系型数据库更强大速度很快。</p></blockquote><h3 id="关系型数据库理论-ACID"><a href="#关系型数据库理论-ACID" class="headerlink" title="关系型数据库理论 - ACID"></a>关系型数据库理论 - ACID</h3><p>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p><ul><li><strong>A – Atomicity – 原子性</strong></li></ul><p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有被执行过一样。</p><ul><li><strong>C – Consistency – 一致性</strong><br>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>I – Isolation – 隔离性</strong><br>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>D – Durability – 持久性</strong><br>事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。</li></ul><p><strong>关系型数据库的优势：</strong></p><p>容易理解: 二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>保持数据的一致性（事务处理）<br>由于以标准化为前提，数据更新的开销很小（相同的字段基本上都只有一处）<br>支持SQL，可以进行Join等复杂查询（几张表之间）</p><p><strong>关系型数据库的不足：</strong></p><ul><li><p>不擅长的处理</p></li><li><p>大量数据的写入处理</p></li><li><p>为有数据更新的表做索引或表结构（schema）变更</p></li><li><p>字段不固定时应用</p></li><li><p>对简单查询需要快速返回结果的处理</p></li></ul><h3 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h3><p>结构不固定，集合内数据字段可以不一样，自由度高，可以减少一些时间和空间的开销。</p><p><strong>四大类型：</strong></p><ul><li>键值对存储（key-value）</li><li>文档存储（document store：mongodb）</li><li>基于列的数据库（column-oriented），还有就是图形数据库（graph database）</li></ul><p><strong>主流的非关系型数据库有 Redis、MongoDB、Cloudant</strong></p><p><strong>特征：</strong></p><ul><li>1、使用键值对存储数据；</li><li>2、分布式；</li><li>3、一般不支持ACID特性；</li><li>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</li><li>5、Redis是单线程加io多路复用的</li></ul><p><strong>优点：</strong></p><ul><li>1、无需经过sql层的解析，读写性能很高；</li><li>2、基于键值对，数据没有耦合性，容易扩展；</li><li>3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。</li><li>4、不支持ACID</li><li>5、不是标准的SQL</li></ul><p><strong>缺点：</strong></p><ul><li>1、不提供sql支持，学习和使用成本较高；</li><li>2、无事务处理，附加功能bi和报表等支持也不好；</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>String: 字符串</li><li>Hash: 散列 (哈希表)</li><li>List: 列表  (链表)</li><li>Set: 集合</li><li>ZSet: 有序不重复集合</li><li>还有新加的里地理位置等类型</li></ul><p><strong>String常用命令例子:<code>set key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</code></strong><br>| 命令            | 作用                   |<br>| ————— | ———————- |<br>| key             | 存储key名字            |<br>| value           | 就是可以对应的存储的值 |<br>| EX seconds      | 超时时间秒单位         |<br>| PX milliseconds | 过期时间毫秒单位       |<br>| NX              | key不存在才能成功设置  |<br>| XX              | key存储才做更新        |</p><h3 id="特点和缺点"><a href="#特点和缺点" class="headerlink" title="特点和缺点"></a>特点和缺点</h3><ul><li>内存存储，读写操作快</li><li>效率高，可用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器，计数器（浏览量!）</li><li>流量限流，消息队列消峰</li><li><code>断电内存数据丢失（所有持久化很重要）</code></li><li><code>RDB，AOF 持久化策略</code></li></ul><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p><strong>1. Linux解决安装一些依赖问题</strong></p><pre><code class="bash">yum groups install Development Tools</code></pre><p><strong>2. 下载解压编译安装</strong></p><pre><code class="bash">$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz$ tar xzf redis-5.0.5.tar.gz$ cd redis-5.0.5$ make</code></pre><p>进入到解压后的 src 目录，通过如下命令启动Redis:</p><p><code>$ src/redis-server</code></p><p>您可以使用内置的客户端与Redis进行交互:</p><pre><code class="bash">$ src/redis-cliredis&gt; set foo barOKredis&gt; get foo&quot;bar&quot;</code></pre><p>ok大功告成。</p><h3 id="配置Redis-conf文件"><a href="#配置Redis-conf文件" class="headerlink" title="配置Redis.conf文件"></a>配置<code>Redis.conf</code>文件</h3><p><strong>常用的参数</strong><br><a href="https://www.runoob.com/redis/redis-conf.html" target="_blank" rel="noopener">点击查看常用的配置参数资料</a></p><h3 id="Redis基本测试redis-benchmark"><a href="#Redis基本测试redis-benchmark" class="headerlink" title="Redis基本测试redis-benchmark"></a><code>Redis</code>基本测试<code>redis-benchmark</code></h3><pre><code class="bash">1    -h    指定服务器主机名    127.0.0.12    -p    指定服务器端口    63793    -s    指定服务器 socket    4    -c    指定并发连接数    505    -n    指定请求数    100006    -d    以字节的形式指定 SET/GET 值的数据大小    27    -k    1=keep alive 0=reconnect    18    -r    SET/GET/INCR 使用随机 key, SADD 使用随机值    9    -P    通过管道传输 &lt;numreq&gt; 请求    110    -q    强制退出 redis。仅显示 query/sec 值    11    --csv    以 CSV 格式输出    12    -l    生成循环，永久执行测试    13    -t    仅运行以逗号分隔的测试命令列表。    14    -I    Idle 模式。仅打开 N 个 idle 连接并等待。    </code></pre><h3 id="性能测试实例"><a href="#性能测试实例" class="headerlink" title="性能测试实例"></a>性能测试实例</h3><p><strong>以下实例我们使用了多个参数来测试 redis 性能：</strong></p><pre><code class="bash">$ redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -qSET: 146198.83 requests per secondLPUSH: 145560.41 requests per second</code></pre><h3 id="Redis持久化策略"><a href="#Redis持久化策略" class="headerlink" title="Redis持久化策略"></a>Redis持久化策略</h3><ul><li>RDB 通过内存快照形式持久化，把数据保存到一个dump.rdb文件中，保存策略是通过定时备份，在配置文件中修改策略 <code>save second count</code>策略，并且在通过关机命令关机时也会自动保存，可以开启压缩模式。</li><li>AOF 是把在Redis运行中所做写操作的命令通过日志的形式保存在一个文件里，就是命令集合。</li></ul><p><strong>RDB的优点：</strong></p><p>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。使用RDB文件进行数据恢复比使用AOF要快很多。</p><p><strong>RDB的缺点：</strong></p><p>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间，影响Redis对外提供服务的能力。</p><p><strong>AOF的优点：</strong></p><p>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</p><p><strong>AOF的缺点：</strong></p><p>AOF文件通常比RDB文件更大性能消耗比RDB高数据恢复速度比RDB慢</p><p>数据持久化引发的延迟</p><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p><p>AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响AOF + fsync every second是比较好的折中方案，每秒fsync一次AOF + fsync never会提供AOF持久化方案下的最优性能使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟</p><p>Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。</p><p>可以通过INFO命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）</p><p>不过大多数应用场景下，建议至少开启RDB方式的数据持久化。Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p><h3 id="Redis分布式几种方案"><a href="#Redis分布式几种方案" class="headerlink" title="Redis分布式几种方案"></a>Redis分布式几种方案</h3><ul><li>主从模式</li><li>哨兵模式</li><li>集群模式</li></ul><h3 id="常用的命令📓"><a href="#常用的命令📓" class="headerlink" title="常用的命令📓"></a>常用的命令📓</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>SELECT n</code></td><td>选择数据库</td></tr><tr><td><code>KEYS *</code></td><td>查看KEY列表</td></tr><tr><td><code>DEL KEY</code></td><td>删除指定KEY</td></tr><tr><td><code>TYPE KEY</code></td><td>查看KEY类型</td></tr><tr><td><code>EXISTS KEY</code></td><td>检查KEY是否存在</td></tr><tr><td><code>SET KEY VALUE</code></td><td>设置KEY和值</td></tr><tr><td><code>GET KEY</code></td><td>获取KEY的值</td></tr><tr><td><code>DBSIZE</code></td><td>查看DB大小</td></tr><tr><td><code>FLUSHDB</code></td><td>清空当前DB</td></tr><tr><td><code>FLUSHALL</code></td><td>清空所有DB</td></tr><tr><td><code>FLUSHALL</code></td><td>清空所有DB</td></tr><tr><td><code>EXPIRE KEY S</code></td><td>设置KEY多久到期/秒</td></tr><tr><td><code>INCR KEY</code></td><td>KEY值自加1</td></tr><tr><td><code>DECR KEY</code></td><td>KEY值自减1</td></tr><tr><td><code>INCRBY KEY 5</code></td><td>设置KEY值自增量</td></tr><tr><td><code>GETRANGE KEY 1 5</code></td><td>获取KEY指定区间的值</td></tr><tr><td><code>STRLEN KEY</code></td><td>获取KEY值长度</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈分布式消息队列</title>
    <link href="/2020/05/27/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2020/05/27/%E6%B5%85%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="什么消息队列"><a href="#什么消息队列" class="headerlink" title="什么消息队列?"></a>什么消息队列?</h2><p><code>消息队列</code>这个词陌生人一听挖槽好牛逼啊好高大上啊，消息队列，一般我们会简称它为<code>MQ(Message Queue)</code>，嗯，就是很直白的简写。</p><ul><li>队列是一种先进先出的数据结构</li><li>消息队列<code>（MessageQueue）</code>是一种应用间的通信方式</li><li>消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象</li><li>消息发送者 可以发送一个消息而无须等待响应。消息发送者 将消息发送到一条 虚拟的通道（主题 或 队列）上，消息接收者 则 订阅 或是 监听 该通道。一条信息可能最终转发给 一个或多个 消息接收者，这些接收者都无需对 消息发送者 做出 同步回应。整个过程都是 异步的。</li></ul><blockquote><p>维基百科上是这么描述的: 在计算机科学中，消息队列是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。</p></blockquote><p><strong>我<code>SDing</code>个人总结就是: 消息队列是一个先进先出的数据存储容器，它可以帮助不同的程序之间进行数据的通讯。</strong></p><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><p>说到消息队列就要说到消息队列里面最常用的方式就是发布和订阅了。</p><blockquote><p>维基百科上是这么描述的: 在软件架构中，发布-订阅是一种消息范式，消息的发送者不会将消息直接发送给特定的接收者。而是将发布的消息分为不同的类别，无需了解哪些订阅者可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。 发布/订阅是消息队列范式的兄弟，通常是更大的面向消息中间件系统的一部分。 </p></blockquote><ul><li>消息生产者 （生产消息发送到消息队列里）</li><li>消息中间件 <code>(Kafka,Nsq,RabbitMQ)</code></li><li>消息消费者  (从消息队列里面拿取订阅的消息)</li></ul><p><strong>我的一句话总结就是: 消息发布和订阅就是一个架构方式，可以在不同的程序之间获取自己需要的数据，解耦模式。</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf7dwe18p4j30hj07vaaq.jpg" srcset="/img/loading.gif" alt="消息队列"></p><p>可以看看这个倔金的文章:<a href="https://juejin.im/post/5cb025fb5188251b0351ef48" target="_blank" rel="noopener">消息队列解耦</a> or <a href="https://juejin.im/post/5b41fe36e51d45191252e79e" target="_blank" rel="noopener">消息队列详解</a></p><h2 id="常见中间件"><a href="#常见中间件" class="headerlink" title="常见中间件"></a>常见中间件</h2><ol><li>NSQ</li><li>Kafka</li><li>ZeroMQ</li><li>MetaMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>ActiveMQ</li><li>Redis (主要是缓存但是也可以实现消息队列)</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code-Server搭建</title>
    <link href="/2020/05/26/Code-Server%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/05/26/Code-Server%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf5z665ly1j30dc06o74k.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>在我们开发调试程序的时候我们的一些程序部署在服务器上运行，但是很多配置文件，这样我们修改起来比较麻烦，使用我们可以通过vscode服务器版本进行开发。</p></blockquote><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>安装可以通过这个<code>https://github.com/cdr/code-server</code>仓库上面的文件来。</p><p><strong>根据自己对应的系统版本安装</strong></p><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian, Ubuntu"></a>Debian, Ubuntu</h3><pre><code class="shell">curl -sSOL https://github.com/cdr/code-server/releases/download/v3.3.1/code-server_3.3.1_amd64.debsudo dpkg -i code-server_3.3.1_amd64.debsystemctl --user enable --now code-server# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml</code></pre><h3 id="Fedora-Red-Hat-SUSE"><a href="#Fedora-Red-Hat-SUSE" class="headerlink" title="Fedora, Red Hat, SUSE"></a>Fedora, Red Hat, SUSE</h3><pre><code class="shell">curl -sSOL https://github.com/cdr/code-server/releases/download/v3.3.1/code-server-3.3.1-amd64.rpmsudo yum install -y code-server-3.3.1-amd64.rpmsystemctl --user enable --now code-server# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml</code></pre><h3 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h3><pre><code class="shell"># Installs code-server from the AUR using yay.yay -S code-serversystemctl --user enable --now code-server# Now visit http://127.0.0.1:8080. Your password is in ~/.config/code-server/config.yaml# Installs code-server from the AUR with plain makepkg.git clone https://aur.archlinux.org/code-server.gitcd code-servermakepkg -sisystemctl --user enable --now code-server</code></pre><p>默认访问地址: <code>http://127.0.0.1:8080</code>. 默认密码配置:<code>~/.config/code-server/config.yaml</code></p><h3 id="Firewall-wall-setting-port"><a href="#Firewall-wall-setting-port" class="headerlink" title="Firewall wall setting port"></a>Firewall wall setting port</h3><p>  <code>–permanent</code> 添加这个参数防火墙永久生效. </p><p>  默认端口是 8080.</p><pre><code>$: firewall-cmd --zone=public --add-port=8080/tcp --permanent# 刷新配置$: firewall-cmd --reload</code></pre><h3 id="Edit-config-file"><a href="#Edit-config-file" class="headerlink" title="Edit config file"></a>Edit config file</h3><p>  使用 <code>vi</code> 打开配置文件<code>~/.config/code-server/config.yaml</code></p><pre><code>$: vi  ~/.config/code-server/config.yaml</code></pre><p>  使用键盘<code>i</code> 键进入insert模式</p><pre><code> bind-addr: 127.0.0.1:8080        auth: password password: 706039b9fa******b847cec0c cert: false ~ ~ -- INSERT --</code></pre><p>   <code>bind-addr</code> 修改为 <code>0.0.0.0:8080</code> (这样就可以远程访问)<br>   <code>password</code> 修改为你自定义密码</p><p>  按键盘上的<code>esc</code> 键输入<code>: wq</code> 保存退出文件</p><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><pre><code>$: /usr/bin/code-server</code></pre><p>output:</p><pre><code>[root@vultr ~]# /usr/bin/code-serverinfo  Wrote default config file to ~/.config/code-server/config.yamlinfo  Using config file ~/.config/code-server/config.yamlinfo  Using user-data-dir ~/.local/share/code-serverinfo  code-server 3.3.1 6f1309795e1cb930edba68cdc7c3dcaa01da0ab3info  HTTP server listening on http://127.0.0.1:8080info      - Using password from ~/.config/code-server/config.yamlinfo      - To disable use `--auth none`info    - Not serving HTTPS</code></pre><p><strong>不需要密码可以添加 <code>-auth none</code> 参数</strong></p><p> <strong>or  start by designated user</strong></p><pre><code>$:  systemctl --user enable --now code-server</code></pre><p> <strong>now visit <a href="http://your.server.address:8080" target="_blank" rel="noopener">http://your.server.address:8080</a>. Good luck~</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Azure上安装Kafka</title>
    <link href="/2020/05/25/Azure%E4%B8%8A%E5%AE%89%E8%A3%85Kafka/"/>
    <url>/2020/05/25/Azure%E4%B8%8A%E5%AE%89%E8%A3%85Kafka/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf4liai3d3j30k008jt9d.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么是Kafka"><a href="#什么是Kafka" class="headerlink" title="什么是Kafka?"></a>什么是Kafka?</h2><p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。<br>对于像 Hadoop 一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka 的目的是通过 Hadoop 的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。<br>Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。<br>Kafka 最初是由领英开发，并随后于 2011 年初开源，并于 2012 年 10 月 23 日由 Apache Incubator 孵化出站。2014 年 11 月，几个曾在领英为 Kafka 工作的工程师，创建了名为 Confluent 的新公司，并着眼于 Kafka。根据 2014 年 Quora 的帖子，Jay Kreps 似乎已经将它以作家弗朗茨·卡夫卡命名。Kreps 选择将该系统以一个作家命名是因为，它是“一个用于优化写作的系统”，而且他很喜欢卡夫卡的作品。</p><p><strong>Kafka 存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka 运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</strong></p><p><strong>Kafka 高效地处理实时流式数据，可以实现与 Storm、HBase 和 Spark 的集成。作为聚类部署到多台服务器上，Kafka 处理它所有的发布和订阅消息系统使用了四个 API，即生产者 API、消费者 API、Stream API 和 Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如 JMS、AMQP 等。</strong></p><p><strong>Kafka 架构的主要术语包括 Topic、Record 和 Broker。Topic 由 Record 组成，Record 持有不同的信息，而 Broker 则负责复制消息。Kafka 有四个主要 API：</strong></p><ul><li>生产者 API：支持应用程序发布 Record 流。</li><li>消费者 API：支持应用程序订阅 Topic 和处理 Record 流。</li><li>Stream API：将输入流转换为输出流，并产生结果。</li><li>Connector API：执行可重用的生产者和消费者 API，可将 Topic 链接到现有应用程序。</li></ul><p><strong>相关术语</strong></p><ul><li>Topic 用来对消息进行分类，每个进入到 Kafka 的信息都会被放到一个 Topic 下</li><li>Broker 用来实现数据存储的主机服务器</li><li>Partition 每个 Topic 中的消息会被分为若干个 Partition，以提高消息的处理效率</li><li>Producer 消息的生产者</li><li>Consumer 消息的消费者</li><li>Consumer Group 消息的消费群组</li></ul><p>由于其广泛集成到企业级基础设施中，监测 Kafka 在规模运行中的性能成为一个日益重要的问题。监测端到端性能，要求跟踪所有指标，包括 Broker、消费者和生产者。除此之外还要监测 ZooKeeper，Kafka 用它来协调各个消费者。当前有一些监测平台可以跟踪卡夫卡的性能，有开源的，如领英的 Burrow；也有付费的，如 Datadog。除了这些平台之外，收集 Kafka 的数据也可以使用工具来进行，这些工具一般需要 Java，包括 JConsole。</p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>Kafaka是基于是JVM运行的程序，所有我们需要先安装JDK或者JRE。<code>(这里就看到了我们的Golang优势！！！！直接编译二进制啊哈哈哈~)</code></p><p><strong>需要Java 1.7或更高版本。因此，您可以如下安装OpenJDK 8</strong></p><pre><code class="shell">sudo yum install -y java-1.13.0-openjdk-devel</code></pre><p><strong>安装了OpenJDK 8后，请使用以下命令验证结果。</strong></p><pre><code class="shell">java -version</code></pre><p><strong>如果一切顺利，输出应与此类似。</strong></p><pre><code class="shelL">openjdk version &quot;1.8.0_252&quot;OpenJDK Runtime Environment (build 1.8.0_252-b09)OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)</code></pre><p><strong>最后，设置JAVA_HOME环境变量。</strong></p><pre><code class="shell">echo &quot;JAVA_HOME=$(readlink -f /usr/bin/java | sed &quot;s:bin/java::&quot;)&quot; | sudo tee -a /etc/profilesource /etc/profile</code></pre><p><strong>安装Kafka</strong></p><pre><code class="shell">wget https://downloads.apache.org/kafka/2.4.1/kafka_2.12-2.4.1.tgz</code></pre><p><strong>解压到opt目录</strong></p><pre><code class="SHELL"> tar -xvf kafka_2.12-2.4.1.tgz -C /opt/</code></pre><p>进入Kafka目录</p><p><code>cd /opt/kafka_2.11-0.9.0.1</code><br>启动Zookeeper服务器</p><p><code>bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</code></p><p>修改Kafka服务器的配置</p><p> <code>vi bin/kafka-server-start.sh</code></p><p>根据您的特定系统参数调整内存使用量。</p><p><code>export KAFKA_HEAP_OPTS=&quot;-Xmx1G -Xms1G&quot;</code></p><p>替换为：</p><p><code>export KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms128M&quot;</code></p><p>保存退出：</p><p><code>:wq</code></p><p>启动Kafka服务器</p><p><code>bin/kafka-server-start.sh config/server.properties</code></p><p>如果一切顺利，您将看到一些有关Kafka服务器状态的消息，最后一条将显示：</p><p><code>INFO [Kafka Server 0], started (kafka.server.KafkaServer)</code></p><p>这意味着您已经启动了Kafka服务器。</p><p>在新的SSH连接中创建主题“测试”</p><p>打开一个新的SSH连接，使用以下命令创建主题“ test”：</p><pre><code class="shell">cd /opt/kafka_2.11-0.9.0.1bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre><p>您可以使用以下命令查看主题：</p><pre><code class="shell">bin/kafka-topics.sh --list --zookeeper localhost:2181</code></pre><p>在我们的例子中，输出将显示为：</p><pre><code class="shell">test</code></pre><p>使用主题“测试”生成消息</p><pre><code class="shell">bin/kafka-console-producer.sh --broker-list localhost:9092 </code></pre><p><code>--topic test</code><br>使用上面的命令，您可以根据需要输入任意数量的消息，例如：</p><pre><code class="shell">Welcome aboard!Bonjour!</code></pre><p>如果您收到与”WARN Error while fetching metadata with correlation id”输入消息时类似的错误，则需要server.properties使用以下信息更新文件：</p><pre><code class="shell">port = 9092advertised.host.name = localhost </code></pre><p>打开第三个SSH连接，然后运行以下命令：</p><pre><code class="shell">cd /opt/kafka_2.11-0.9.0.1bin/kafka-console-consumer.sh --zookeeper localhost:9092 --topic test --from-beginning</code></pre><ul><li>您先前生成的消息将显示在第三个SSH连接中。当然，如果您现在从第二个SSH连接输入更多消息，您将立即在第三个SSH连接上看到它们。</li></ul><p>最后，您可以在每个SSH连接上按Ctrl + C组合键以停止这些脚本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Centos7</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSQ之弹射起步</title>
    <link href="/2020/05/19/NSQ%E4%B9%8B%E5%BC%B9%E5%B0%84%E8%B5%B7%E6%AD%A5/"/>
    <url>/2020/05/19/NSQ%E4%B9%8B%E5%BC%B9%E5%B0%84%E8%B5%B7%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gey1a5ssbvj30p00dw77v.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="NSQ是什么？？？"><a href="#NSQ是什么？？？" class="headerlink" title="NSQ是什么？？？"></a><code>NSQ</code>是什么？？？</h2><p><strong><code>NSQ</code>是<code>Go</code>语言编写的一个开源的实时分布式内存消息队列，其性能十分优异。 NSQ的优势有以下优势：</strong></p><ul><li><code>NSQ</code>提倡分布式和分散的拓扑，没有单点故障，支持容错和高可用性，并提供可靠的消息交付保证</li><li><code>NSQ</code>支持横向扩展，没有任何集中式代理。</li><li><code>NSQ</code>易于配置和部署，并且内置了管理界面。</li></ul><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列?"></a>什么是消息队列?</h2><p>通俗地解释一下消息队列，你想象一个场景：你到报社订阅了一份报纸，报社每日生产一份新报纸，便将新报纸发往邮局并告诉邮局你的地址，邮递员将你的报纸送往你的邮箱，你便可以愉快地阅读今天的时事新闻了。当然，可能一个人订阅了好几家报社，一家报社也可以被多个人订阅。在这个场景中，消息队列就担任了，邮箱、邮局、邮递员的角色。</p><h2 id="消息队列的作用？"><a href="#消息队列的作用？" class="headerlink" title="消息队列的作用？"></a>消息队列的作用？</h2><ul><li>是减少相应所需的时间和削峰</li><li>降低系统耦合性解耦或提升系统的可拓展性）</li></ul><p><strong>如图下场景:</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gextpsdc8qj313e0u0wja.jpg" srcset="/img/loading.gif" alt="nsq"><br><strong>通过使用消息队列将不同的业务逻辑解耦，降低系统间的耦合，提高系统的健壮性。后续有其他业务要使用订单数据可直接订阅消息队列，提高系统的灵活性。</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gextqm9slzj30wi0jg409.jpg" srcset="/img/loading.gif" alt="nsq"><br><strong>还可以帮大并发做流量抗压处理，类似秒杀（大秒）等场景下，某一时间可能会产生大量的请求，使用消息队列能够为后端处理请求提供一定的缓冲区，保证后端服务的稳定性。</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gextrsvl7uj30xc08uwf9.jpg" srcset="/img/loading.gif" alt="nsq"></p><h2 id="开始NSQ弹射起步🚀"><a href="#开始NSQ弹射起步🚀" class="headerlink" title="开始NSQ弹射起步🚀"></a>开始<code>NSQ</code>弹射起步🚀</h2><p><strong>NSQ工作模式👇</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexu2qzvroj31480u0792.jpg" srcset="/img/loading.gif" alt="nsq"></p><p><code>Topic</code>和<code>Channel</code><br>每个<code>nsqd</code>实例旨在一次处理多个数据流。这些数据流称为<code>“topics”</code>，一个<code>topic</code>具有1个或多个<code>“channels”</code>。每个<code>channel</code>都会收到<code>topic</code>所有消息的副本，实际上下游的服务是通过对应的<code>channel</code>来消费<code>topic</code>消息。</p><p><code>topic</code>和<code>channel</code>不是预先配置的。<code>topic</code>在首次使用时创建，方法是将其发布到指定<code>topic</code>，或者订阅指定<code>topic</code>上的<code>channel</code>。<code>channel</code>是通过订阅指定的<code>channel</code>在第一次使用时创建的。</p><p><code>topic</code>和<code>channel</code>都相互独立地缓冲数据，防止缓慢的消费者导致其他<code>chennel</code>的积压（同样适用于<code>topic</code>级别）。</p><p><code>channel</code>可以并且通常会连接多个客户端。假设所有连接的客户端都处于准备接收消息的状态，则每条消息将被传递到随机客户端。例如：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexw4g26pog30bo07tjry.gif" srcset="/img/loading.gif" alt="nsq"><br>总而言之，消息是从<code>topic -&gt; channel</code>（每个<code>channel</code>接收该<code>topic</code>的所有消息的副本）多播的，但是从<code>channel -&gt; consumers</code>均匀分布（每个消费者接收该<code>channel</code>的一部分消息）。<br><strong>NSQ接收和发送消息流程</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexu6v1zghj30fc07paah.jpg" srcset="/img/loading.gif" alt=""><br><strong>NSQ特性</strong><br>消息默认不持久化，可以配置成持久化模式。nsq采用的方式时内存+硬盘的模式，当内存到达一定程度时就会将数据持久化到硬盘。</p><ul><li>如果将<code>--mem-queue-size</code>设置为0，所有的消息将会存储到磁盘。</li><li>服务器重启时也会将当时在内存中的消息持久化。</li><li>每条消息至少传递一次。</li><li>消息不保证有序。</li></ul><h3 id="开始使用NSQ"><a href="#开始使用NSQ" class="headerlink" title="开始使用NSQ"></a>开始使用<code>NSQ</code></h3><p>首先我们需要安装NSQ的<code>nsqlookupd</code>组件也就是<code>nsqd</code>程序,浏览器打开<a href="https://nsq.io/deployment/installing.html" target="_blank" rel="noopener">官方下载页面</a>即可得到你对应操作系统的程序。<br><strong><code>nsqd</code>是一个守护进程，它接收、排队并向客户端发送消息。</strong></p><h3 id="nsqlookupd组件"><a href="#nsqlookupd组件" class="headerlink" title="nsqlookupd组件"></a><code>nsqlookupd</code>组件</h3><p><code>nsqlookupd</code>相当于集群的管理员所以我们首先启动它</p><pre><code class="shell">$ nsqlookupd</code></pre><h3 id="nsqd组件"><a href="#nsqd组件" class="headerlink" title="nsqd组件"></a><code>nsqd</code>组件</h3><p>启动 <code>nsqd</code>，它相当于集群下的节点，是主要干活的</p><pre><code class="shell">$ nsqd --lookupd-tcp-address=127.0.0.1:4160</code></pre><p><strong><code>nsqlookupd</code>是维护所有<code>nsqd</code>状态、提供服务发现的守护进程。它能为消费者查找特定<code>topic</code>下的<code>nsqd</code>提供了运行时的自动发现服务。 它不维持持久状态，也不需要与任何其他<code>nsqlookupd</code>实例协调以满足查询。因此根据你系统的冗余要求尽可能多地部署<code>nsqlookupd</code>节点。它们消耗的资源很少，可以与其他服务共存。我们的建议是为每个数据中心运行至少3个集群。</strong></p><h3 id="nsqadmin组件"><a href="#nsqadmin组件" class="headerlink" title="nsqadmin组件"></a><code>nsqadmin</code>组件</h3><p>一个实时监控集群状态、执行各种管理任务的Web管理平台。 启动<code>nsqadmin</code>，指定<code>nsqlookupd</code>地址:</p><pre><code class="shell"> ./nsqadmin -lookupd-http-address=127.0.0.1:4161</code></pre><p>我们可以使用浏览器打开<code>http://127.0.0.1:4171/</code>访问如下管理界面。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvk9mzt7j31c00u0b29.jpg" srcset="/img/loading.gif" alt="nsq"></p><h3 id="测试消息"><a href="#测试消息" class="headerlink" title="测试消息"></a>测试消息</h3><p>发送一条消息</p><pre><code class="shell">$ curl -d &#39;hello world 1&#39; &#39;http://127.0.0.1:4151/pub?topic=test&#39;</code></pre><p>即可看到收到了消息<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvqdbqrrj31740u0k9x.jpg" srcset="/img/loading.gif" alt="nsq"><br>把消息写到硬盘的文件里</p><pre><code class="shell">$ nsq_to_file --topic=test --output-dir=/tmp --lookupd-http-address=127.0.0.1:4161</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvtcplxej312i0u07c5.jpg" srcset="/img/loading.gif" alt="nsq"><br>文件内容<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gexvukbk33j31ja0m614z.jpg" srcset="/img/loading.gif" alt="nsq"></p><p><strong>好了如果对你有帮助你可以到本博客的关于页面添加我微信或者在Github联系我，一起推动Golang在中国这片土地生根发芽长成大树！！！Good luck!</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>NSQ</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gohper成长秘籍</title>
    <link href="/2020/05/17/Gohper%E7%9A%84300%E9%97%AE/"/>
    <url>/2020/05/17/Gohper%E7%9A%84300%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevv4s06cej30dw04zjs2.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>这是我个人<code>Denn</code>整理的一套Golang学习目录<br> ✅ 表示我已经完成的<br> 🤷‍♀️ 表示我了解过没有深入<br> 加油各位少年🍻</p></blockquote><h1 id="目录树🌲"><a href="#目录树🌲" class="headerlink" title="目录树🌲"></a>目录树🌲</h1><ul><li>常量和变量的关系 ✅</li><li>基本数据类型和引用类型  ✅</li><li>程序的运算符  ✅</li><li>程序控制流程  ✅</li><li>数组的使用  ✅</li><li><code>slice</code>、<code>map</code>、<code>channel</code>的使用  ✅</li><li>函数式编程  ✅</li><li>结构体和指针  ✅</li><li>面向接口编程  ✅</li><li>包和目录的概念  ✅</li><li>反射和不安全编程 🤷‍♀️</li><li>测试包的使用  ✅</li><li>常用的内置的使用  ✅</li><li><code>Goroutine</code>和<code>Comtext</code>  ✅</li><li>网络编程和数据库编程  ✅<ul><li><code>Gin</code></li><li><code>Gorm</code></li><li><code>gRPC</code> </li><li><code>Redis</code></li><li><code>Nsq</code></li><li><code>Kafka</code></li><li><code>MongoDB</code></li><li><code>Etcd</code></li><li><code>ElasticSearch</code></li><li><code>......还有跟多需要不断努力🏃‍♀️</code></li></ul></li><li>算法和数据结构补一补</li><li>找一些计算机组成和计算机基础视频看看~</li><li>Good Luck！！！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go性能分析之PProf</title>
    <link href="/2020/05/16/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8BPProf/"/>
    <url>/2020/05/16/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8BPProf/</url>
    
    <content type="html"><![CDATA[<h2 id="PProf是个啥？？？"><a href="#PProf是个啥？？？" class="headerlink" title="PProf是个啥？？？"></a>PProf是个啥？？？</h2><p><code>pprof</code>是用于可视化和分析性能分析数据的工具,<code>pprof</code>以 <code>profile.proto</code> 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）<br><code>profile.proto</code> 是一个<code>Protocol Buffer v3</code>的描述文件，它描述了一组 <code>callstack</code>和 <code>symbolization</code>信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 <code>stacktrace</code>配置文件格式。</p><ol><li>支持什么使用模式<ul><li><code>Report generation</code>：报告生成</li><li><code>Interactive terminal use</code>：交互式终端使用</li><li><code>Web interface</code>：<code>Web</code> 界面</li></ul></li><li>可以做什么<ul><li><code>CPU Profiling</code>：<code>CPU</code> 分析，按照一定的频率采集所监听的应用程序 <code>CPU</code>（含寄存器）的使用情况，可确定应用程序在主动消耗 <code>CPU</code> 周期时花费时间的位置</li><li><code>Memory Profiling</code>：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li><li><code>Block Profiling</code>：阻塞分析，记录 <code>goroutine</code> 阻塞等待同步（包括定时器通道）的位置</li><li><code>Mutex Profiling</code>：互斥锁分析，报告互斥锁的竞争情况</li></ul></li></ol><h2 id="一个例子🌰"><a href="#一个例子🌰" class="headerlink" title="一个例子🌰"></a>一个例子🌰</h2><p><strong>想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：</strong></p><ul><li><code>runtime/pprof</code>：采集程序（<code>非 Server</code>）的运行数据进行分析</li><li><code>net/http/pprof</code>：采集 <code>HTTP Server</code> 的运行时数据进行分析</li></ul><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/16 - 12:53 下午package mainimport (    &quot;flag&quot;    &quot;fmt&quot;    &quot;os&quot;    &quot;runtime/pprof&quot;    &quot;time&quot;)// 一段有问题的代码func logicCode() {    var c chan int    for {        select {        case v := &lt;-c:            fmt.Printf(&quot;recv from chan, value:%v\n&quot;, v)        default:        }    }}func main() {    var isCPUPprof bool    var isMemPprof bool    flag.BoolVar(&amp;isCPUPprof, &quot;cpu&quot;, false, &quot;turn cpu pprof on&quot;)    flag.BoolVar(&amp;isMemPprof, &quot;mem&quot;, false, &quot;turn mem pprof on&quot;)    flag.Parse()    if isCPUPprof {         file, err := os.Create(&quot;./cpu.pprof&quot;)        if err != nil {            fmt.Printf(&quot;create cpu pprof failed, err:%v\n&quot;, err)            return        }        pprof.StartCPUProfile(file)        defer pprof.StopCPUProfile()    }    for i := 0; i &lt; 8; i++ {        go logicCode()    }    time.Sleep(20 * time.Second)    if isMemPprof {        file, err := os.Create(&quot;./mem.pprof&quot;)        if err != nil {            fmt.Printf(&quot;create mem pprof failed, err:%v\n&quot;, err)            return        }        pprof.WriteHeapProfile(file)        file.Close()    }}</code></pre><p><strong>可以看到👆上面的那个<code>select</code>代码块里面的channel没有初始化，会一直阻塞着。这样一个简单的代码可以通过我们肉眼出来了，但是如果是复杂的我们就需要使用<code>pprof</code>工具了。</strong></p><pre><code class="shell">$: go tool pprof cpu.pprof Type: cpuTime: May 16, 2020 at 12:59pm (CST)Duration: 20.14s, Total samples = 56.90s (282.48%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) top3Showing nodes accounting for 51.91s, 91.23% of 56.90s totalDropped 7 nodes (cum &lt;= 0.28s)Showing top 3 nodes out of 4      flat  flat%   sum%        cum   cum%    23.04s 40.49% 40.49%     45.18s 79.40%  runtime.selectnbrecv    17.26s 30.33% 70.83%     18.93s 33.27%  runtime.chanrecv    11.61s 20.40% 91.23%     56.83s 99.88%  main.logicCode //❎这里已经通过工具分析出来了！！！</code></pre><p><strong>工具就可以分析出来了我们的<code>logicCode</code>函数有问题！</strong></p><pre><code class="shell">$: go tool pprof cpu.pprof Type: cpuTime: May 16, 2020 at 12:59pm (CST)Duration: 20.14s, Total samples = 56.90s (282.48%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) top3Showing nodes accounting for 51.91s, 91.23% of 56.90s totalDropped 7 nodes (cum &lt;= 0.28s)Showing top 3 nodes out of 4      flat  flat%   sum%        cum   cum%    23.04s 40.49% 40.49%     45.18s 79.40%  runtime.selectnbrecv    17.26s 30.33% 70.83%     18.93s 33.27%  runtime.chanrecv    11.61s 20.40% 91.23%     56.83s 99.88%  main.logicCode(pprof) list logicCodeTotal: 56.90sROUTINE ======================== main.logicCode in /Users/ding/Documents/GO_CODE_DEV/src/Lets_Go/lets_37_pprof/main.go    11.61s     56.83s (flat, cum) 99.88% of Total         .          .     16:// 一段有问题的代码         .          .     17:func logicCode() {         .          .     18:   var c chan int         .          .     19:   for {         .          .     20:           select {    11.61s     56.83s     21:           case v := &lt;-c:         .          .     22:                   fmt.Printf(&quot;recv from chan, value:%v\n&quot;, v)         .          .     23:           default:         .          .     24:         .          .     25:           }         .          .     26:   }(pprof) </code></pre><p><strong>通过<code>list funcName</code>就可以定位到哪行代码的问题了！当然<code>PProf</code>工具的用途多的是这里就是一个简单的例子，我这篇博文就写到这里，有兴趣的后面再更新，或者关注我的公众号:<code>go_code</code>谢谢里面有干货哦<del>~</del>🤩</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>PPorf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Testing of Golang</title>
    <link href="/2020/05/15/Testing-of-Golang/"/>
    <url>/2020/05/15/Testing-of-Golang/</url>
    
    <content type="html"><![CDATA[<h2 id="GoLang的单元测试"><a href="#GoLang的单元测试" class="headerlink" title="GoLang的单元测试"></a>GoLang的单元测试</h2><p>在我们写代码的过程中要养成一个写注释和写单元测试的习惯，这样可以提高我们的代码健壮性和可读性，今天我们就来介绍一下<code>golang</code>的<code>test</code>这个工具。</p><h2 id="go-test命令介绍"><a href="#go-test命令介绍" class="headerlink" title="go test命令介绍"></a><code>go test</code>命令介绍</h2><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p><p><code>go test</code>命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th>类型</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td>测试函数</td><td>函数名前缀为<code>Test</code></td><td>测试程序的一些逻辑行为是否正确</td></tr><tr><td>基准函数</td><td>函数名前缀为<code>Benchmark</code></td><td>测试函数的性能</td></tr><tr><td>示例函数</td><td>函数名前缀为<code>Example</code></td><td>为文档提供示例文档</td></tr></tbody></table><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><blockquote><p>基本测试的一些方法说明在文档里:<a href="https://studygolang.com/static/pkgdoc/pkg/testing.htm" target="_blank" rel="noopener">https://studygolang.com/static/pkgdoc/pkg/testing.htm</a></p></blockquote><p><strong>本测试的函数<code>math.go</code></strong></p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/15 - 4:16 下午package lets_36_testingfunc init() {    Math := make(map[string]func(n, m int) int, 4)    Math[&quot;add&quot;] = Add    Math[&quot;sub&quot;] = Sub    Math[&quot;multi&quot;] = Multi    Math[&quot;div&quot;] = Div}func Add(n, m int) int {    return n + m}func Sub(n, m int) int {    return n - m}func Multi(n, m int) int {    return n * m}func Div(n, m int) int {    return n / m}</code></pre><p><strong>测试函数<code>math_test.go</code>遵循官方命名规范</strong></p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/15 - 4:21 下午package lets_36_testingimport &quot;testing&quot;func TestMath(t *testing.T) {    // 自定义测试结构体    type MathCase struct {        n, m, result int    }    // 自定义子测试map    testGroup := map[string]MathCase{        &quot;add&quot;:   {1, 2, 3},        &quot;sub&quot;:   {3, 1, 2},        &quot;multi&quot;: {3, 2, 6},        &quot;div&quot;:   {6, 2, 3},    }    // 测试执行函数    for name, mathCase := range testGroup {        t.Run(name, func(t *testing.T) {            s := -1            switch name {            case &quot;add&quot;:                s = Add(mathCase.n, mathCase.m)            case &quot;sub&quot;:                s = Sub(mathCase.n, mathCase.m)            case &quot;multi&quot;:                s = Multi(mathCase.n, mathCase.m)            case &quot;div&quot;:                s = Div(mathCase.n, mathCase.m)            default:                t.Fatalf(&quot;No executable testing name :%s&quot;, name)            }            if mathCase.result != s {                t.Fatalf(&quot; add computer result error， want %d , got %d&quot;, mathCase.result, s)            }        })    }}</code></pre><p><strong>在自己的terminal输入<code>go test</code>即可看到测试结果</strong></p><pre><code class="go">=== RUN   TestMath=== RUN   TestMath/sub=== RUN   TestMath/multi=== RUN   TestMath/div=== RUN   TestMath/add--- PASS: TestMath (0.00s)    --- PASS: TestMath/sub (0.00s)    --- PASS: TestMath/multi (0.00s)    --- PASS: TestMath/div (0.00s)    --- PASS: TestMath/add (0.00s)PASSok      command-line-arguments  0.004s</code></pre><blockquote><p>如果是子测试可以加 <code>-run=funcName/TestCase</code>来进行子测试</p></blockquote><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。Go提供内置功能来检查你的代码覆盖率。我们可以使用<code>go test -cover</code>来查看测试覆盖率，例如：</p><pre><code class="go">$: go test -coverPASScoverage: 100.0% of statementsok      Lets_Go/lets_36_testing 0.004s</code></pre><p><strong>可以看到我的代码测试覆盖率是百分之百的~</strong></p><p>Go还提供了一个额外的<code>go test -cover -coverprofile</code>参数，用来将覆盖率相关的记录信息输出到一个文件里:</p><pre><code class="go">$: go test -cover -coverprofile=testInfo.out[50 50 50 50 50 50]PASScoverage: 100.0% of statementsok      Lets_Go/lets_36_testing 0.005s</code></pre><p><strong>这样我们就把测试的信息输出到一个指定的<code>testInfo.out</code>文件里面了,然后我们通过go语言内置<code>tool</code>工具就可以生产可视化的代码覆盖率检查视图了，使用命令<code>go tool cover -html=testInfo.out</code>例如:</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1getd9mki8bj313u0u0dve.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>基准测试是给你的程序做运行性能的测试,以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。</p><pre><code class="go">func BenchmarkAdd(b *testing.B) {    for i:=0;i&lt;b.N;i++ {        Add(i, b.N)        //fmt.Println(add)    }}</code></pre><p><strong>增加<code>-bench</code>参数，所以我们通过执行<code>go test -bench=Add</code>命令执行基准测试，输出结果如下</strong></p><pre><code class="go">$: go test -bench=Addgoos: darwingoarch: amd64pkg: Lets_Go/lets_36_testingBenchmarkAdd-4          1000000000               0.281 ns/opPASSok      Lets_Go/lets_36_testing 0.320s</code></pre><p><strong>其中BenchmarkAdd-4表示对Split函数进行基准测试，数字4表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Add函数耗时0.281ns，这个结果是10000000次调用的平均值。</strong></p><p>还可以添加<code>-benchmem</code>参数来查看被查内存使用情况:</p><pre><code class="go">$: go test -bench=Add -benchmemgoos: darwingoarch: amd64pkg: Lets_Go/lets_36_testingBenchmarkAdd-4          1000000000               0.292 ns/op           0 B/op          0 allocs/opPASSok      Lets_Go/lets_36_testing 0.335s</code></pre><p><strong><code>0 B/op</code>表示每次操作内存分配了<code>0</code>字节，<code>0 allocs/op</code>则表示每次操作进行了<code>0</code>次内存分配,因为我写的就是一个简单加法函数😁</strong></p><blockquote><p>Good luck😜~</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sync.Mutex&amp;RWMutex笔记</title>
    <link href="/2020/05/12/sync-Mutex-RWMutex%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/05/12/sync-Mutex-RWMutex%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-中锁的使用"><a href="#Go-中锁的使用" class="headerlink" title="Go 中锁的使用"></a>Go 中锁的使用</h2><ol><li>互斥锁</li><li>读写锁</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gepy9opn7vj30ge0gq3yz.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>并发程序对公共资源访问的限制最常见的就是使用互斥锁的方式。在Go中，sync.Mutex 提供了互斥锁的实现。</p><p>简单使用示例：</p><pre><code class="go">func main() {var mutex sync.Mutexcount := 0for r := 0; r &lt; 50; r++ {   go func() {           mutex.Lock()           count += 1           mutex.Unlock()       }()   }   time.Sleep(time.Second)   fmt.Println(&quot;the count is : &quot;, count)}</code></pre><p>当执行了 <code>mutex.Lock()</code> 操作后，如果有另外一个 <code>goroutine</code> 又执行了上锁操作，那么该操作被被阻塞，直到该互斥锁恢复到解锁状态。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>顾名思义，读写锁是对读写操作进行加锁。需要注意的是多个读操作之间不存在互斥关系，这样提高了对共享资源的访问效率。</p><p>Go中读写锁由 <code>sync.RWMutex</code>提供，主要包括：</p><ul><li><p><code>func (rw *RWMutex) Lock()</code></p></li><li><p><code>func (rw *RWMutex) RLock()</code></p></li><li><p><code>func (rw *RWMutex) RLocker() Locker</code></p></li><li><p><code>func (rw *RWMutex) RUnlock()</code></p></li><li><p><code>func (rw *RWMutex) Unlock()</code></p></li></ul><p>其中 <code>Lock()</code> 即“写锁定”，调用了“写锁定”后，不能有其他<code>goroutine</code>进行读或者写操作。 <code>Unlock()</code> 即“写解锁”，调用了“写解锁”后会唤醒所有因为要进行“读锁定（即:<code>RLock()</code>）” 而被阻塞的 <code>goroutine</code>。</p><p><code>RLock()</code>为“读锁定”，调用“读锁定”后，不能有其他<code>goroutine</code>进行写操作，但是可以进行读操作。<code>RUnlock()</code> 为“读解锁”，调用“读解锁”后，会唤醒一个因为要进行“写锁定”而被阻塞的<code>goroutine</code>。</p><p>简单使用示例：</p><pre><code class="go">package mainimport (&quot;fmt&quot;&quot;sync&quot;&quot;time&quot;)func main() {    var mutex sync.RWMutex    arr := []int{1, 2, 3}    go func() {       fmt.Println(&quot;Try to lock writing operation.&quot;)       mutex.Lock()       fmt.Println(&quot;Writing operation is locked.&quot;)       arr = append(arr, 4)       fmt.Println(&quot;Try to unlock writing operation.&quot;)       mutex.Unlock()       fmt.Println(&quot;Writing operation is unlocked.&quot;)   }()   go func() {       fmt.Println(&quot;Try to lock reading operation.&quot;)       mutex.RLock()       fmt.Println(&quot;The reading operation is locked.&quot;)       fmt.Println(&quot;The len of arr is : &quot;, len(arr))       fmt.Println(&quot;Try to unlock reading operation.&quot;)       mutex.RUnlock()       fmt.Println(&quot;The reading operation is unlocked.&quot;)   }()   time.Sleep(time.Second * 2)   return}</code></pre><p>运行以上示例，观察输出结果，你将能够比较直观的感受到读写锁的作用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>读写锁</tag>
      
      <tag>Mutex</tag>
      
      <tag>RWMutex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP黏包</title>
    <link href="/2020/05/11/TCP%E9%BB%8F%E5%8C%85/"/>
    <url>/2020/05/11/TCP%E9%BB%8F%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包?"></a>什么是TCP粘包?</h2><ol><li>通常我在自己写程序的时候写一个基于<code>tcp</code>协议通讯的程序时就会发生这种问题。</li><li>我们在<code>Client</code>端快速发送数据包并且这个包数据是随机,时间间隔也很短,然后<code>tcp</code>的<code>Server</code>拿到数据就会是我们之前<code>Client</code>发送的多条数据包合在的一起的，导致我们不能区分具体是哪个数据包的。</li><li>为什么会产生这种原因就是因为<code>tcp</code>在传输的是<code>字节流协议</code>。<blockquote><p>上面是我个人自学习过程中总结的大家可以看看这个链接上的解释:<br><a href="https://www.liwenzhou.com/posts/Go/15_socket/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/15_socket/</a></p></blockquote></li></ol><h2 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h2><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ul><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geosakdma0j30on0brabp.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="通过Go语言实现"><a href="#通过Go语言实现" class="headerlink" title="通过Go语言实现"></a>通过Go语言实现</h2><blockquote><p>server.go</p></blockquote><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/11 - 7:14 下午package mainimport (    &quot;fmt&quot;    &quot;net&quot;)func main() {    listen, err := net.Listen(&quot;tcp&quot;, &quot;localhost:9598&quot;)    if err != nil {        fmt.Println(&quot;create tcp server fail.&quot;,err)        return    }    var msg [1024]byte    for{        accept, err := listen.Accept()        if err != nil {            fmt.Println(&quot;tcp accept fail&quot;,err)            return        }        n , _ := accept.Read(msg[:])        fmt.Println(string(msg[:n]))    }}</code></pre><blockquote><p>client.go</p></blockquote><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/11 - 7:58 下午package mainimport (    &quot;fmt&quot;    &quot;net&quot;    &quot;time&quot;)func main() {    dial, err := net.Dial(&quot;tcp&quot;, &quot;localhost:9598&quot;)    if err != nil {        fmt.Println(&quot;connection tcp server fail.&quot;,err)    }    for i:=0;i&lt;10;i++ {        dial.Write([]byte(&quot;Hello&quot; + time.Now().Format(&quot;2006-01-02 15:04:05.0000&quot;)))    }}</code></pre><blockquote><p>OutPut</p></blockquote><pre><code> ~/Documents/GO_CODE_DEV/src/Lets_Go/lets_33_tcp_黏包  master ✚  ↵ 1  go run server.goHello2020-05-11 20:16:13.5448Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449</code></pre><p><strong>可以看到所有数据包都被黏在一起了！！！！这就是我们所说的tcp黏包。</strong></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>出现黏包的原因是因为服务器端或者消息接受者不知道我们每次发送的数据包大小！！所以我们可以自定义一个数据包格式来解决。就像我们出去约别人吃饭一样的，我们俩先商量好去哪里地方几点…..(例子有点抽象不好理解啊哈哈哈)</p></blockquote><blockquote><p>protocol.go</p></blockquote><pre><code class="go">package mainimport (    &quot;bufio&quot;    &quot;bytes&quot;    &quot;encoding/binary&quot;)// Encode 将消息编码func Encode(message string) ([]byte, error) {    // 读取消息的长度，转换成int32类型（占4个字节）    var length = int32(len(message))    // 创建缓冲区    var pkg = new(bytes.Buffer)    // 写入消息头 “小端方式写入存储”这里我也不太清楚看别人写的例子,用就完事了    err := binary.Write(pkg, binary.LittleEndian, length)    if err != nil {        return nil, err    }    // 在包头后面 追加 写入消息实体    err = binary.Write(pkg, binary.LittleEndian, []byte(message))    if err != nil {        return nil, err    }    return pkg.Bytes(), nil}// Decode 解码消息func Decode(reader *bufio.Reader) (string, error) {    // 读取消息的长度    lengthByte, _ := reader.Peek(4) // 读取前4个字节的数据    lengthBuff := bytes.NewBuffer(lengthByte)    var length int32    err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)    if err != nil {        return &quot;&quot;, err    }    // Buffered返回缓冲中现有的可读取的字节数。    if int32(reader.Buffered()) &lt; length+4 {        return &quot;&quot;, err    }    // 读取真正的消息数据    pack := make([]byte, int(4+length))    _, err = reader.Read(pack)    if err != nil {        return &quot;&quot;, err    }    return string(pack[4:]), nil}</code></pre><p><strong>接下来在服务端和客户端分别使用上面定义的Decode和Encode函数处理数据。下面有我的源代码仓库,Good Luck~😜</strong><br><strong><a href="https://github.com/higker/Lets_Go/tree/master/lets_33_tcp_%E9%BB%8F%E5%8C%85" target="_blank" rel="noopener">https://github.com/higker/Lets_Go/tree/master/lets_33_tcp_%E9%BB%8F%E5%8C%85</a></strong></p><h2 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h2><blockquote><p>为什么udp不会粘包?<br><a href="https://zhuanlan.zhihu.com/p/41709589?utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41709589?utm_source=wechat_session</a></p></blockquote><p>1.TCP协议是面向流的协议，UDP是面向消息的协议</p><p>UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据</p><p>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说就容易进行区分处理了。传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。接收端一次只能接收发送端发出的一个数据包,如果一次接受数据的大小小于发送端一次发送的数据大小，就会丢失一部分数据，即使丢失，接受端也不会分两次去接收</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈并发和并行</title>
    <link href="/2020/05/08/%E8%B0%88%E8%B0%88%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
    <url>/2020/05/08/%E8%B0%88%E8%B0%88%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是并发？"><a href="#什么是并发？" class="headerlink" title="什么是并发？"></a>什么是并发？</h2><p> 就是在一段时间里来回切换做多个事情，就像一个快递员在一分钟内送完我的快递又继续去送的快递，干活的就只要一个快递员(这个例子有点不好还是看下面图片吧)。<code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelclh44mgj308704j74e.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么并行？"><a href="#什么并行？" class="headerlink" title="什么并行？"></a>什么并行？</h2><p>在同一时刻内处理多个事情，就像一个2个快递员在同时时间内分别给你我送快递。(他们2个在同一个时间内同时干活，效率高)。<code>并行(parallel)：</code>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geldwbtva1j308p04mgln.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么区别？"><a href="#什么区别？" class="headerlink" title="什么区别？"></a>什么区别？</h2><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发（Concurrent）。</p><p>当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行（Parallel）。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geld285ybjj30i40ea750.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>看图非常容易理解：</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geld3btporj30o909faaz.jpg" srcset="/img/loading.gif" alt=""><br>上图中将一个任务中的三个步骤取柴、运柴、卸柴划分成了独立的小任务，有取柴的老鼠，有运柴的老鼠，有卸柴烧火的老鼠。<br>如果上图中所有的老鼠都是同一只，那么是串行并发的，如果是不同的多只老鼠，那么是并行并发的。</p><h4 id="并行和串行："><a href="#并行和串行：" class="headerlink" title="并行和串行："></a>并行和串行：</h4><ul><li>串行：一次只能取得一个任务并执行这一个任务</li><li>并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务</li><li>注意点：<ul><li>如果是单进程/单线程的并行，那么效率比串行更差</li><li>如果只有单核cpu，多进程并行并没有提高效率</li><li>从任务队列上看，由于同时从队列中取得多个任务并执行，相当于将一个长任务队列变成了短队列</li></ul></li></ul><h3 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h3><ul><li>并发是一种现象：同时运行多个程序或多个任务需要被处理的现象</li><li>这些任务可能是并行执行的，也可能是串行执行的，和CPU核心数无关，是操作系统进程调度和CPU上下文切换达到的结果</li><li>解决大并发的一个思路是将大任务分解成多个小任务：</li><li>可能要使用一些数据结构来避免切分成多个小任务带来的问题</li><li>可以多进程/多线程并行的方式去执行这些小任务达到高效率</li><li>或者以单进程/单线程配合多路复用执行这些小任务来达到高效率</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>计算机知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之高阶函数</title>
    <link href="/2020/04/24/Go%E4%B9%8B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2020/04/24/Go%E4%B9%8B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是高阶函数-？"><a href="#什么是高阶函数-？" class="headerlink" title="什么是高阶函数??？"></a>什么是高阶函数??？</h1><p>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数，编写高阶函数，就是让函数的参，能够接收别的函数，函数式编程就是指这种高度抽象的编程范式。</p><h1 id="高阶函数的特点"><a href="#高阶函数的特点" class="headerlink" title="高阶函数的特点"></a>高阶函数的特点</h1><ul><li>变量可以指向函数</li></ul><p><code>函数本身也可以赋值给变量，即：变量可以指向函数</code></p><pre><code class="go">package main//go语言导包import (    m &quot;Lets_Go/lets_18_package/math&quot; //起别名  自定义包名也就是给“math“起个别名    &quot;fmt&quot;)func main() {    multip := m.SimpleCompute(&quot;+&quot;)    fmt.Println(multip(2, 8))}</code></pre><ul><li>返回值也是函数</li></ul><pre><code class="go">/*    闭包高阶函数*/func SimpleCompute(Symbol string) func(n, m int) int {    switch Symbol {    case &quot;+&quot;:        return func(n, m int) int {            return n + m        }    case &quot;-&quot;:        return func(n, m int) int {            return n - m        }    case &quot;*&quot;:        return func(n, m int) int {            return n * m        }    case &quot;/&quot;:        return func(n, m int) int {            return n / m        }    default:        panic(&quot;compute symbol invalid.&quot;)    }}</code></pre><ul><li>函数可作为参数</li></ul><p><code>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数一个最简单的高阶函数</code></p><pre><code class="go">package mainimport &quot;fmt&quot;//go语言中的闭包操作func main() {    f1(f3(f2, 5, 5))}//1.限制函数类型的函数func f1(f func()) {    f()}//2.现在的需求就要把我们的f2函数传递到f1函数里面进行调用func f2(a, b int) int {    fmt.Println(&quot;f2() am f1() exec succeed&quot;)    fmt.Println(&quot;a + b = ? 在f3中的匿名函数中调用:&quot;)    return a + b}//3.通过闭包解决func f3(fn func(int, int) int, a, b int) (Rf func()) { //返回值名字必须是“Rf” 不想用就不需要写直接写返回值类型    //这个就是取一个中间变量存储 并且 在函数里面声明一个匿名无返回值的函数    // := 这里如果函数返回值已经在函数名上写着了 就不能使用 := 因为已经在创建函数时已经声明了    Rf = func() {        sum := fn(a, b) //接受返回值 然后打印        fmt.Println(&quot;sum=&quot;, sum)    }    return Rf}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之channel浅入了解</title>
    <link href="/2020/04/23/Go%E4%B9%8Bchannel%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/04/23/Go%E4%B9%8Bchannel%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Go语言的channel？"><a href="#什么是Go语言的channel？" class="headerlink" title="什么是Go语言的channel？"></a>什么是Go语言的channel？</h2><blockquote><p>在Go语言中,Channel即指通道类型。有时也用它来直接指代可以传递某种类型的值的通道。</p></blockquote><p>channel是Go语言中的一个核心类型，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯，这在一定程度上又进一步降低了编程的难度。<br>channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题。<br>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。<br>引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3kqrcxboj30dw072mxe.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="属性和基本操作"><a href="#属性和基本操作" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h2><ul><li>基于通道的通讯是在多个Goroutine之间进行同步的重要手段。而针对通道的操作本身也是同步的。</li><li>在同一时刻，仅有一个Goroutine能向一个通道发送元素值</li><li>同时也仅有一个Goroutine能从它那里接收元素值。</li><li>通道相当于一个FIFO先进先出的消息队列。</li><li>通道中的元素值都具有原子性。它们是不可被分割的。通道中的每一个元素都只可能被某一个Goroutine接收。已被接收的元素值会立刻被从通道中删除。</li></ul><h2 id="有缓冲的channel"><a href="#有缓冲的channel" class="headerlink" title="有缓冲的channel"></a>有缓冲的channel</h2><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个数据值的通道。<br>这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。<br>只有通道中没有要接收的值时，接收动作才会阻塞。<br>只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。<br>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p><p>示例图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3kigisnoj30m70ewtaf.jpg" srcset="/img/loading.gif" alt=""></p><p>在第 1 步，右侧的 goroutine 正在从通道接收一个值。<br>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道里。<br>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine 正在从通道接收另外一个值。这个步骤里的两个操作既不是同步的，也不会互相阻塞。<br>最后，在第 4 步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</p><p><em>使用示例</em></p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/4/22 - 3:15 下午package mainimport (    &quot;fmt&quot;    &quot;sync&quot;)var wg sync.WaitGroup//go语言的channel 通道//go语言使用goroutine执行多个task任务//操作一个map或者其他变量或者内存时会发生数据竞争//使用go里面使用channel来解决并发并行来解决func main() {    //channel类型 相当于一个队列 first in -&gt; first out 先进先出原则    //定义一个channel类型 channel是一个引用类型 需要开辟空间    var ch chan int    fmt.Println(ch == nil) //true    //初始化一个无缓冲区的通道    ch = make(chan int)    wg.Add(1)    go func (){        defer wg.Done()        x := &lt;- ch        fmt.Println(x)    }()    ch &lt;- 2048 //会卡死main的主goroutine从而不能让程序进行执行    fmt.Println(ch) //无缓冲区的channel不能放入值    fmt.Println(ch == nil) //false    //初始化一个带缓冲区的通道    bufChan := make(chan int,8)    fmt.Println(cap(bufChan)) //8 CAP可以换取通道缓冲区大小    //发送值 使用这个&quot;&lt;-符号&quot; 获取也一样    bufChan &lt;- 1024    num := &lt;-bufChan    fmt.Println(bufChan)    fmt.Println(num)    wg.Wait()}</code></pre><blockquote><p>上面部分内容转载于链接：<a href="https://www.jianshu.com/p/e611d30feb9d" target="_blank" rel="noopener">https://www.jianshu.com/p/e611d30feb9d</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>goroutine</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之goroutine浅入了解</title>
    <link href="/2020/04/22/Go%E4%B9%8Bgoroutine%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/04/22/Go%E4%B9%8Bgoroutine%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么goroutine"><a href="#1-什么goroutine" class="headerlink" title="1.什么goroutine?"></a>1.什么goroutine?</h1><p>goroutine是Go并行设计的核心。goroutine说到底其实就是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。<br>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p><p>Goroutine是建立在线程之上的轻量级的抽象。它允许我们以非常低的代价在同一个地址空间中并行地执行多个函数或者方法。相比于线程，它的创建和销毁的代价要小很多，并且它的调度是独立于线程的。在golang中创建一个goroutine非常简单，使用“go”关键字即可：</p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/4/21 - 6:09 下午package mainimport (    &quot;fmt&quot;    &quot;math/rand&quot;    &quot;sync&quot;    &quot;time&quot;)var (    //这个是go里面用来配置goroutine使用的    //只能操作指针 因为他是一个struct 值类型！！！    wg sync.WaitGroup    //存放我们for的数字方便观察    sls []int)//go语言中的多个goroutine//WaitGroupfunc main() {    fmt.Println(&quot;goroutine begin:&quot;, sls)    for i := 0; i &lt;= 10; i++ {        // fatal error: all goroutines are asleep - deadlock!        //注意这里加的1不是i如果是i的话每次都是加的不一样然后出现👆的异常！！！        wg.Add(1)        go task(i)    }    fmt.Println(&quot;InService:&quot;, sls)    wg.Wait()    fmt.Println(&quot;End Over:&quot;, sls)}// fatal error: all goroutines are asleep - deadlock!func task(num int) {    defer func() {        wg.Done()    }()    //随机休眠几毫秒    time.Sleep(duration())    //将for循环的i存入到切片中我们等下好观察,    //打印控制台太慢了回漏掉    sls = append(sls, num) //不安全}//生成一个随机的等待时间 = 毫秒func duration() time.Duration {    rand.Seed(time.Now().UnixNano())    return time.Millisecond * time.Duration(rand.Intn(3000))}</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code class="shell">goroutine begin: []InService: []End Over: [4 10 9 8 6 1 0 3 2]</code></pre><blockquote><p>会出现一个问题多次运行你会发现有时候结果的slice会少一个数,这是因为，和线程一样，golang的主函数（其实也跑在一个goroutine中）并不会等待其它goroutine结束。如果主goroutine结束了，所有其它goroutine都将结束,所有后面我们就会将到go的channel来解决问题~数据竞争和数据共享,多个goroutine之间的通讯问题。</p></blockquote><h3 id="Goroutine与线程的区别"><a href="#Goroutine与线程的区别" class="headerlink" title="Goroutine与线程的区别"></a>Goroutine与线程的区别</h3><p>许多人认为goroutine比线程运行得更快，这是一个误解。Goroutine并不会更快，它只是增加了更多的并发性。当一个goroutine被阻塞（比如等待IO），golang的scheduler会调度其它可以执行的goroutine运行。与线程相比，它有以下几个优点：</p><h3 id="内存消耗更少："><a href="#内存消耗更少：" class="headerlink" title="内存消耗更少："></a>内存消耗更少：</h3><p>Goroutine所需要的内存通常只有2kb，而线程则需要1Mb（500倍）。<br>内存消耗更少：</p><h3 id="创建与销毁的开销更小"><a href="#创建与销毁的开销更小" class="headerlink" title="创建与销毁的开销更小"></a>创建与销毁的开销更小</h3><p>由于线程创建时需要向操作系统申请资源，并且在销毁时将资源归还，因此它的创建和销毁的开销比较大。相比之下，goroutine的创建和销毁是由go语言在运行时自己管理的，因此开销更低。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2mjdldsfj30hs0a5q3h.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="切换开销更小"><a href="#切换开销更小" class="headerlink" title="切换开销更小"></a>切换开销更小</h3><p>这是goroutine于线程的主要区别，也是golang能够实现高并发的主要原因。线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，就会被其它可执行的线程抢占。在线程切换的过程中需要保存/恢复所有的寄存器信息，比如16个通用寄存器，PC（Program Counter），SP（Stack Pointer），段寄存器等等。</p><p>而goroutine的调度是协同式的，它不会直接地与操作系统内核打交道。当goroutine进行切换的时候，之后很少量的寄存器需要保存和恢复（PC和SP）。因此gouroutine的切换效率更高。</p><h3 id="Goroutine的调度"><a href="#Goroutine的调度" class="headerlink" title="Goroutine的调度"></a>Goroutine的调度</h3><p>真如前面提到的，goroutine的调度方式是协同式的。在协同式调度中，没有时间片的概念。为了并行执行goroutine，调度器会在以下几个时间点对其进行切换：</p><h3 id="Channel接受或者发送会造成阻塞的消息"><a href="#Channel接受或者发送会造成阻塞的消息" class="headerlink" title="Channel接受或者发送会造成阻塞的消息"></a>Channel接受或者发送会造成阻塞的消息</h3><p>当一个新的goroutine被创建时<br>可以造成阻塞的系统调用，如文件和网络操作<br>垃圾回收<br>下面让我们来看一下调度器具体是如何工作的。Golang调度器中有三个概念</p><ul><li>Processor（P）</li><li>OSThread（M）</li><li>Goroutines（G）</li></ul><p>在一个Go程序中，可用的线程数是通过GOMAXPROCS来设置的，默认值是可用的CPU核数。我们可以用runtime包动态改变这个值。OSThread调度在processor上，goroutines调度在OSThreads上<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2ml5ze1wj30hs08at98.jpg" srcset="/img/loading.gif" alt=""><br>Golang的调度器可以利用多processor资源，在任意时刻，M个goroutine需要被调度到N个OS threads上，同时这些threads运行在至多GOMAXPROCS个processor上（N &lt;= GOMAXPROCS）。Go scheduler将可运行的goroutines分配到多个运行在一个或多个processor上的OS threads上。</p><p>每个processor有一个本地goroutine队列。同时有一个全局的goroutine队列。每个OSThread都会被分配给一个processor。最多只能有GOMAXPROCS个processor，每个processor同时只能执行一个OSThread。Scheculer可以根据需要创建OSThread。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2mlz0si1j30hs08j74l.jpg" srcset="/img/loading.gif" alt=""><br>在每一轮调度中，scheduler找到一个可以运行的goroutine并执行直到其被阻塞,由此可见，操作系统的一个线程下可以并发执行上千个goroutine，每个goroutine所占用的资源和切换开销都很小，因此，goroutine是golang适合高并发场景的重要原因。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>golang</tag>
      
      <tag>goroutine</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac上配置Golang开发环境</title>
    <link href="/2020/03/13/Mac%E4%B8%8A%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/03/13/Mac%E4%B8%8A%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/13/JYRMzrxeKlLNp26.jpg" srcset="/img/loading.gif" alt="Golang"></p><blockquote><p><strong>📝本篇文章记录我本人在Mac上配置Go开发环境的笔记📒</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Go Source Code</a></li><li>Go是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 罗伯特·格瑞史莫，罗勃·派克及肯·汤普逊于2007年9月开始设计Go，稍后Ian Lance Taylor、Russ Cox加入项目。Go是基于Inferno操作系统所开发的。</li><li>Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行计算模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，[2]，但它也具有pipeline模型的特征，比如通道传输。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。与C++相比，Go并不包括如枚举、异常处理、继承、泛型、断言、虚函数等功能，但增加了 切片(Slice) 型、并发、管道、垃圾回收功能、接口等特性的语言级支持[2]。Go 2.0版本将支持泛型[7]，对于断言的存在，则持负面态度，同时也为自己不提供类型继承来辩护。不同于Java，Go原生提供了关联数组（也称为哈希表（Hashes）或字典（Dictionaries）），就像字符串类型一样。</li></ul><h2 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h2><ul><li><a href="https://go.dev/" target="_blank" rel="noopener">Go Dev</a></li><li>浏览器🔛打开上面👆链接下载官方安装包<br><img src="https://i.loli.net/2020/03/13/XosNZdnTVtr3auA.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-13_15-54-37.jpg"></li><li>下载的时候根据自己系统版本下载对应的安装包</li><li>下载完成之后双击安装包即可安装</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>我本人Mac是使用的<code>iTerm2 + Oh My Zsh + zsh</code>所以我只需要编辑我的<code>~/.zshrc</code>文件📃即可.</p><ul><li>通过vscode打开<pre><code class="bash">code ~/.zshrc</code></pre></li><li>在文件最后添加修改配置<pre><code class="bash">##go语言环境配置 ##go 语言安装主根目录export GOROOT=/usr/local/go#GOPATH是自己的go项目路径，自定义设置export GOPATH=/Users/ding/Documents/GO_CODE_DEV# 启用 Go Modules 功能export GO111MODULE=on# 配置 GOPROXY 环境变量 &amp; 国内网络环境大家都知道不多说export GOPROXY=https://goproxy.io,directexport PATH=$PATH:$GOBIN:$GOPATH/bin:GO111MODULE:GOPROXY</code></pre></li><li>然后使用<code>source ~/.zshrc</code>文件</li><li>在terminal里面输入<code>go env</code>即可查看环境<br><img src="https://i.loli.net/2020/03/13/3hrCzjTS5D4MlKJ.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-13_16-07-43.jpg"></li></ul><h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><p>我个人使用vscode比较多一点,Goland在开发大型项目才使用<br><strong>VS Code官方下载地址：<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a></strong><br>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。双击下载好的安装文件，双击安装即可。</p><ul><li><h4 id="安装Go语言开发工具包"><a href="#安装Go语言开发工具包" class="headerlink" title="安装Go语言开发工具包"></a>安装Go语言开发工具包</h4><p>在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。<br>Windows平台按下Ctrl+Shift+P，Mac平台按Command+Shift+P，这个时候VS Code界面会弹出一个输入框，如下图：<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535662106193.jpg" srcset="/img/loading.gif" alt="GO"><br>我们在这个输入框中输入<code>&gt;go:install</code>，下面会自动搜索相关命令，我们选择<code>Go:Install/Update Tools</code>这个命令<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535659707162.jpg" srcset="/img/loading.gif" alt="GOINSTALL"><br>选中并会回车执行该命令（或者使用鼠标点击该命令）<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535665573387.jpg" srcset="/img/loading.gif" alt="golang"></p></li><li><h4 id="配置代码片段快捷键"><a href="#配置代码片段快捷键" class="headerlink" title="配置代码片段快捷键"></a>配置代码片段快捷键</h4><p>还是按Ctrl/Command+Shift+P,按下图输入<code>&gt;snippets</code>，选择命令并执行<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535687503862.jpg" srcset="/img/loading.gif" alt="GO"><br>配置<code>snippets</code>代码片段模本<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535688890224.jpg" srcset="/img/loading.gif" alt="GO SNIPPETS"><br>大家可以简单看下上面的注释，介绍了主要用法：</p><pre><code class="json">    “这里放个名字”:{      &quot;prefix&quot;: &quot;这个是快捷键&quot;,      &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,      &quot;description&quot;: &quot;这里放提示信息的描述&quot;    }</code></pre><p> 其中<code>$0</code>表示最终光标提留的位置。举个例子，我这里创建了两个快捷方式，一个是输入<code>pln</code>就会在编辑器中插入<code>fmt.Println()</code>代码；输入<code>plf</code>，就会插入<code>fmt.Printf(&quot;&quot;)</code>代码。</p><pre><code class="json">  {    &quot;println&quot;:{      &quot;prefix&quot;: &quot;pln&quot;,      &quot;body&quot;:&quot;fmt.Println($0)&quot;,      &quot;description&quot;: &quot;println&quot;    },    &quot;printf&quot;:{      &quot;prefix&quot;: &quot;plf&quot;,      &quot;body&quot;: &quot;fmt.Printf(\&quot;$0\&quot;)&quot;,      &quot;description&quot;: &quot;printf&quot;    }  }</code></pre><p>添加如上配置后，保存。 我们打开一个go文件，测试一下效果：<br> <img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/demo1.gif" srcset="/img/loading.gif" alt="fmt.println"></p></li></ul><p><strong>好了配置完成,开始愉快的coding吧👨‍💻‍Good luck~😜</strong>   </p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Golang</tag>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo集成gitalk评论组件</title>
    <link href="/2020/03/08/Hexo%E9%9B%86%E6%88%90gitalk%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/03/08/Hexo%E9%9B%86%E6%88%90gitalk%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/BayMRX/Blog_source@master/img/hexo.jpg" srcset="/img/loading.gif" alt="hexo"></p><blockquote><p><strong>一个基于 Github Issue 和 Preact 开发的评论插件,下面我们就来使用gitalk来实现hexo的评论功能。</strong></p></blockquote><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk开源地址</a></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>使用 GitHub 登录</li><li>支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]</li><li>支持个人或组织</li><li>无干扰模式（设置 distractionFreeMode 为 true 开启）</li><li>快捷键提交评论 （cmd|ctrl + enter）</li></ul><p><a href="https://github.com/gitalk/gitalk/blob/master/readme.md" target="_blank" rel="noopener">Readme</a><br><a href="https://gitalk.github.io" target="_blank" rel="noopener">在线示例</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>两种方式</p><ul><li>直接引入</li></ul><pre><code class="html">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;  &lt;!-- or --&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>npm 安装</li></ul><pre><code class="sh">npm i --save gitalk</code></pre><pre><code class="js">import &#39;gitalk/dist/gitalk.css&#39;import Gitalk from &#39;gitalk&#39;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加一个容器：</p><pre><code class="html">&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</code></pre><p>用下面的 Javascript 代码来生成 gitalk 插件：</p><pre><code class="js">var gitalk = new Gitalk({  clientID: &#39;GitHub Application Client ID&#39;,  clientSecret: &#39;GitHub Application Client Secret&#39;,  repo: &#39;GitHub repo&#39;,  owner: &#39;GitHub repo owner&#39;,  admin: [&#39;GitHub repo owner and collaborators, only these guys can initialize github issues&#39;],  id: location.pathname,      // Ensure uniqueness and length less than 50  distractionFreeMode: false  // Facebook-like distraction free mode})gitalk.render(&#39;gitalk-container&#39;)</code></pre><p>需要 <strong>GitHub Application</strong>，如果没有 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击这里申请</a>，<code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p><p><strong>⚠️更多帮助在官方文档,可以在官方链接里查询。</strong></p><h2 id="设置GitHub"><a href="#设置GitHub" class="headerlink" title="设置GitHub"></a>设置GitHub</h2><ul><li>在个人设置里面创建一个Application<br><img src="https://i.loli.net/2020/03/08/fKqE9JHALBXMnN7.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-07_12-46-47.jpg"></li><li>然后我们需要的ClientID和Token<br><img src="https://i.loli.net/2020/03/08/vAx7wkRFhsNyqtX.jpg" srcset="/img/loading.gif" alt="clientId"></li><li>创建一个存放lssue仓库<br><img src="https://i.loli.net/2020/03/08/jeBmlY2RD6Fi35E.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-07_13-00-14.jpg"><h2 id="在Hexo里使用"><a href="#在Hexo里使用" class="headerlink" title="在Hexo里使用"></a>在Hexo里使用</h2><blockquote><p>这里我使用的主题里面已经集成了gitalk,所有我们直接修改配置文件就可以了。根据个人配置方法不同查询各种文档！！！</p></blockquote></li></ul><p>下面是我的配置文件📃</p><pre><code class="yaml"># Gitalk# You can get yout ClientID and ClientSecret from https://github.com/settings/applications/new# More info available at https://github.com/gitalk/gitalk#optionsgitalk:  clientID: 这里填写你之前application的clientID # GitHub Application Client ID  clientSecret: 之前申请的 # GitHub Application Client Secret  repo: ibyte.me # The repo to store comments  owner: deencode # GitHub repository owner. Can be personal user or organization.  admin: deencode # GitHub repo owner and collaborators, only these guys can initialize github issues, should be like &quot;[&#39;admin&#39;]&quot; or &quot;[&#39;admin1&#39;,&#39;admin2&#39;]&quot;  id: location.pathname # The unique id of the page. Length must less than 50.  language: zh-CN # Localization language key, en, zh-CN and zh-TW are currently available.  labels: &quot;[&#39;Gitalk&#39;]&quot; # GitHub issue labels.  perPage: 15 # Pagination size, with maximum 100.  pagerDirection: last # Comment sorting direction, available values are last and first.  distractionFreeMode: false # Facebook-like distraction free mode.  createIssueManually: true # By default, Gitalk will create a corresponding github issue for your every single page automatically when the logined user is belong to the admin users. You can create it manually by setting this option to true.</code></pre><p><strong>配置方法不同有所差异!!根据自己使用的插件查询官方文档进行的配置！！！Good Luck😜</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>gitalk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo搭建Blog</title>
    <link href="/2020/03/06/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BABlog/"/>
    <url>/2020/03/06/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BABlog/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/06/cOUwFstAaTeyGQk.jpg" srcset="/img/loading.gif" alt="Hexo&amp;GithubPage.jpg"></p><h3 id="1-相关网站"><a href="#1-相关网站" class="headerlink" title="1. 相关网站"></a>1. 相关网站</h3><ul><li>[Github]: <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></li><li>[Hexo]: <a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li><li>[Hexo Theme]: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>[Hexo Docs]: <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li></ul><h3 id="2-创建Github-Key"><a href="#2-创建Github-Key" class="headerlink" title="2. 创建Github Key"></a>2. 创建Github Key</h3><p>设置你的用户名称与邮件地址，如果是第一次使用git的话</p><pre><code class="bash">$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com</code></pre><p>使用ssh-keygen生成私钥和公钥<br>命令如下：</p><pre><code class="bash">$ ssh-keygen -t rsa</code></pre><p>然后到你GitHub 设置里面添加你刚才生成的xx.pub的内容到Key里面.</p><pre><code class="bash">$ ssh -T git@github.com</code></pre><p>登录Github，点击头像下的settings，添加ssh,新建一个new ssh key，将id_rsa.pub文件里的内容复制上去。</p><p>输入ssh -T <a href="mailto:git@github.com">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了。</p><p>这里你可以去创建一个public的仓库来存储等下Hexo相关的文件.</p><h3 id="3-安装NPM和Hexo"><a href="#3-安装NPM和Hexo" class="headerlink" title="3. 安装NPM和Hexo"></a>3. 安装NPM和Hexo</h3><ul><li>[NodeJS网站]: <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></li></ul><p>通过上面的网站下载对应的系统版本的NodeJS安装包.</p><ol><li><strong>设置NPM源到淘宝源</strong></li></ol><pre><code class="bash">   npm config set registry https://registry.npmjs.org/</code></pre><ol start="2"><li><p><strong>NPM安装HexoCli</strong></p><p>输入npm install hexo -g，开始安装Hexo</p></li></ol><pre><code class="bash">   npm install hexo -g</code></pre><ol start="3"><li><p><strong>初始化Hexo</strong></p><p>输入hexo -v，检查hexo是否安装成功</p><p>输入hexo init，初始化该文件夹（有点漫长的等待…）看到后面的“Start blogging with Hexo！”就说明初始化好了</p><p>输入npm install，安装所需要的组件</p></li></ol><pre><code class="bash">$ hexo -v$ hexo init$ hexo install        </code></pre><h3 id="4-配置config-yml文件"><a href="#4-配置config-yml文件" class="headerlink" title="4.配置config.yml文件"></a>4.配置config.yml文件</h3><p><strong>PS:这里根据自己需要自己配置，你可以去查询官方文档！！</strong></p><pre><code class="bash">deploy:  type: git  repo: git@github.com:Deencode/ibyte.me.git  branch: master</code></pre><h3 id="5-生成静态文件-amp-上传到GitHub仓库"><a href="#5-生成静态文件-amp-上传到GitHub仓库" class="headerlink" title="5.生成静态文件&amp;上传到GitHub仓库"></a>5.生成静态文件&amp;上传到GitHub仓库</h3><p><strong>🎉: 到了这一步就差不多了，运行下面命令就可以生成文件了.</strong></p><pre><code class="bash">#生成文件$ hexo generate#监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件#在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。$ hexo generate --watch# 本地运行$ hexo server#您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。$ hexo deploy</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
