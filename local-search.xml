<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP粘包(粘包)</title>
    <link href="/2020/05/11/TCP%E7%B2%98%E5%8C%85-%E9%BB%8F%E5%8C%85/"/>
    <url>/2020/05/11/TCP%E7%B2%98%E5%8C%85-%E9%BB%8F%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是TCP粘包"><a href="#什么是TCP粘包" class="headerlink" title="什么是TCP粘包?"></a>什么是TCP粘包?</h2><ol><li>通常我在自己写程序的时候写一个基于<code>tcp</code>协议通讯的程序时就会发生这种问题。</li><li>我们在<code>Client</code>端快速发送数据包并且这个包数据是随机,时间间隔也很短,然后<code>tcp</code>的<code>Server</code>拿到数据就会是我们之前<code>Client</code>发送的多条数据包合在的一起的，导致我们不能区分具体是哪个数据包的。</li><li>为什么会产生这种原因就是因为<code>tcp</code>在传输的是<code>字节流协议</code>。<blockquote><p>上面是我个人自学习过程中总结的大家可以看看这个链接上的解释:<br><a href="https://www.liwenzhou.com/posts/Go/15_socket/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/15_socket/</a></p></blockquote></li></ol><h2 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h2><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ul><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geosakdma0j30on0brabp.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="通过Go语言实现"><a href="#通过Go语言实现" class="headerlink" title="通过Go语言实现"></a>通过Go语言实现</h2><blockquote><p>server.go</p></blockquote><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/11 - 7:14 下午package mainimport (    &quot;fmt&quot;    &quot;net&quot;)func main() {    listen, err := net.Listen(&quot;tcp&quot;, &quot;localhost:9598&quot;)    if err != nil {        fmt.Println(&quot;create tcp server fail.&quot;,err)        return    }    var msg [1024]byte    for{        accept, err := listen.Accept()        if err != nil {            fmt.Println(&quot;tcp accept fail&quot;,err)            return        }        n , _ := accept.Read(msg[:])        fmt.Println(string(msg[:n]))    }}</code></pre><blockquote><p>client.go</p></blockquote><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/5/11 - 7:58 下午package mainimport (    &quot;fmt&quot;    &quot;net&quot;    &quot;time&quot;)func main() {    dial, err := net.Dial(&quot;tcp&quot;, &quot;localhost:9598&quot;)    if err != nil {        fmt.Println(&quot;connection tcp server fail.&quot;,err)    }    for i:=0;i&lt;10;i++ {        dial.Write([]byte(&quot;Hello&quot; + time.Now().Format(&quot;2006-01-02 15:04:05.0000&quot;)))    }}</code></pre><blockquote><p>OutPut</p></blockquote><pre><code> ~/Documents/GO_CODE_DEV/src/Lets_Go/lets_33_tcp_黏包  master ✚  ↵ 1  go run server.goHello2020-05-11 20:16:13.5448Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449Hello2020-05-11 20:16:13.5449</code></pre><p><strong>可以看到所有数据包都被黏在一起了！！！！这就是我们所说的tcp黏包。</strong></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>出现黏包的原因是因为服务器端或者消息接受者不知道我们每次发送的数据包大小！！所以我们可以自定义一个数据包格式来解决。就像我们出去约别人吃饭一样的，我们俩先商量好去哪里地方几点…..(例子有点抽象不好理解啊哈哈哈)</p></blockquote><blockquote><p>protocol.go</p></blockquote><pre><code class="go">package mainimport (    &quot;bufio&quot;    &quot;bytes&quot;    &quot;encoding/binary&quot;)// Encode 将消息编码func Encode(message string) ([]byte, error) {    // 读取消息的长度，转换成int32类型（占4个字节）    var length = int32(len(message))    // 创建缓冲区    var pkg = new(bytes.Buffer)    // 写入消息头 “小端方式写入存储”这里我也不太清楚看别人写的例子,用就完事了    err := binary.Write(pkg, binary.LittleEndian, length)    if err != nil {        return nil, err    }    // 在包头后面 追加 写入消息实体    err = binary.Write(pkg, binary.LittleEndian, []byte(message))    if err != nil {        return nil, err    }    return pkg.Bytes(), nil}// Decode 解码消息func Decode(reader *bufio.Reader) (string, error) {    // 读取消息的长度    lengthByte, _ := reader.Peek(4) // 读取前4个字节的数据    lengthBuff := bytes.NewBuffer(lengthByte)    var length int32    err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)    if err != nil {        return &quot;&quot;, err    }    // Buffered返回缓冲中现有的可读取的字节数。    if int32(reader.Buffered()) &lt; length+4 {        return &quot;&quot;, err    }    // 读取真正的消息数据    pack := make([]byte, int(4+length))    _, err = reader.Read(pack)    if err != nil {        return &quot;&quot;, err    }    return string(pack[4:]), nil}</code></pre><p><strong>接下来在服务端和客户端分别使用上面定义的Decode和Encode函数处理数据。Good Luck~😜</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>tcp</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈并发和并行</title>
    <link href="/2020/05/08/%E8%B0%88%E8%B0%88%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
    <url>/2020/05/08/%E8%B0%88%E8%B0%88%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是并发？"><a href="#什么是并发？" class="headerlink" title="什么是并发？"></a>什么是并发？</h2><p> 就是在一段时间里来回切换做多个事情，就像一个快递员在一分钟内送完我的快递又继续去送的快递，干活的就只要一个快递员(这个例子有点不好还是看下面图片吧)。<code>并发(concurrency)</code>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gelclh44mgj308704j74e.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么并行？"><a href="#什么并行？" class="headerlink" title="什么并行？"></a>什么并行？</h2><p>在同一时刻内处理多个事情，就像一个2个快递员在同时时间内分别给你我送快递。(他们2个在同一个时间内同时干活，效率高)。<code>并行(parallel)：</code>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geldwbtva1j308p04mgln.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="什么区别？"><a href="#什么区别？" class="headerlink" title="什么区别？"></a>什么区别？</h2><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><p>当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发（Concurrent）。</p><p>当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行（Parallel）。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geld285ybjj30i40ea750.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>看图非常容易理解：</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geld3btporj30o909faaz.jpg" srcset="/img/loading.gif" alt=""><br>上图中将一个任务中的三个步骤取柴、运柴、卸柴划分成了独立的小任务，有取柴的老鼠，有运柴的老鼠，有卸柴烧火的老鼠。<br>如果上图中所有的老鼠都是同一只，那么是串行并发的，如果是不同的多只老鼠，那么是并行并发的。</p><h4 id="并行和串行："><a href="#并行和串行：" class="headerlink" title="并行和串行："></a>并行和串行：</h4><ul><li>串行：一次只能取得一个任务并执行这一个任务</li><li>并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务</li><li>注意点：<ul><li>如果是单进程/单线程的并行，那么效率比串行更差</li><li>如果只有单核cpu，多进程并行并没有提高效率</li><li>从任务队列上看，由于同时从队列中取得多个任务并执行，相当于将一个长任务队列变成了短队列</li></ul></li></ul><h3 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h3><ul><li>并发是一种现象：同时运行多个程序或多个任务需要被处理的现象</li><li>这些任务可能是并行执行的，也可能是串行执行的，和CPU核心数无关，是操作系统进程调度和CPU上下文切换达到的结果</li><li>解决大并发的一个思路是将大任务分解成多个小任务：</li><li>可能要使用一些数据结构来避免切分成多个小任务带来的问题</li><li>可以多进程/多线程并行的方式去执行这些小任务达到高效率</li><li>或者以单进程/单线程配合多路复用执行这些小任务来达到高效率</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>计算机知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之高阶函数</title>
    <link href="/2020/04/24/Go%E4%B9%8B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2020/04/24/Go%E4%B9%8B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是高阶函数-？"><a href="#什么是高阶函数-？" class="headerlink" title="什么是高阶函数??？"></a>什么是高阶函数??？</h1><p>一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数，编写高阶函数，就是让函数的参，能够接收别的函数，函数式编程就是指这种高度抽象的编程范式。</p><h1 id="高阶函数的特点"><a href="#高阶函数的特点" class="headerlink" title="高阶函数的特点"></a>高阶函数的特点</h1><ul><li>变量可以指向函数</li></ul><p><code>函数本身也可以赋值给变量，即：变量可以指向函数</code></p><pre><code class="go">package main//go语言导包import (    m &quot;Lets_Go/lets_18_package/math&quot; //起别名  自定义包名也就是给“math“起个别名    &quot;fmt&quot;)func main() {    multip := m.SimpleCompute(&quot;+&quot;)    fmt.Println(multip(2, 8))}</code></pre><ul><li>返回值也是函数</li></ul><pre><code class="go">/*    闭包高阶函数*/func SimpleCompute(Symbol string) func(n, m int) int {    switch Symbol {    case &quot;+&quot;:        return func(n, m int) int {            return n + m        }    case &quot;-&quot;:        return func(n, m int) int {            return n - m        }    case &quot;*&quot;:        return func(n, m int) int {            return n * m        }    case &quot;/&quot;:        return func(n, m int) int {            return n / m        }    default:        panic(&quot;compute symbol invalid.&quot;)    }}</code></pre><ul><li>函数可作为参数</li></ul><p><code>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数一个最简单的高阶函数</code></p><pre><code class="go">package mainimport &quot;fmt&quot;//go语言中的闭包操作func main() {    f1(f3(f2, 5, 5))}//1.限制函数类型的函数func f1(f func()) {    f()}//2.现在的需求就要把我们的f2函数传递到f1函数里面进行调用func f2(a, b int) int {    fmt.Println(&quot;f2() am f1() exec succeed&quot;)    fmt.Println(&quot;a + b = ? 在f3中的匿名函数中调用:&quot;)    return a + b}//3.通过闭包解决func f3(fn func(int, int) int, a, b int) (Rf func()) { //返回值名字必须是“Rf” 不想用就不需要写直接写返回值类型    //这个就是取一个中间变量存储 并且 在函数里面声明一个匿名无返回值的函数    // := 这里如果函数返回值已经在函数名上写着了 就不能使用 := 因为已经在创建函数时已经声明了    Rf = func() {        sum := fn(a, b) //接受返回值 然后打印        fmt.Println(&quot;sum=&quot;, sum)    }    return Rf}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之channel浅入了解</title>
    <link href="/2020/04/23/Go%E4%B9%8Bchannel%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/04/23/Go%E4%B9%8Bchannel%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Go语言的channel？"><a href="#什么是Go语言的channel？" class="headerlink" title="什么是Go语言的channel？"></a>什么是Go语言的channel？</h2><blockquote><p>在Go语言中,Channel即指通道类型。有时也用它来直接指代可以传递某种类型的值的通道。</p></blockquote><p>channel是Go语言中的一个核心类型，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯，这在一定程度上又进一步降低了编程的难度。<br>channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题。<br>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。<br>引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3kqrcxboj30dw072mxe.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="属性和基本操作"><a href="#属性和基本操作" class="headerlink" title="属性和基本操作"></a>属性和基本操作</h2><ul><li>基于通道的通讯是在多个Goroutine之间进行同步的重要手段。而针对通道的操作本身也是同步的。</li><li>在同一时刻，仅有一个Goroutine能向一个通道发送元素值</li><li>同时也仅有一个Goroutine能从它那里接收元素值。</li><li>通道相当于一个FIFO先进先出的消息队列。</li><li>通道中的元素值都具有原子性。它们是不可被分割的。通道中的每一个元素都只可能被某一个Goroutine接收。已被接收的元素值会立刻被从通道中删除。</li></ul><h2 id="有缓冲的channel"><a href="#有缓冲的channel" class="headerlink" title="有缓冲的channel"></a>有缓冲的channel</h2><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个数据值的通道。<br>这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。<br>只有通道中没有要接收的值时，接收动作才会阻塞。<br>只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。<br>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p><p>示例图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge3kigisnoj30m70ewtaf.jpg" srcset="/img/loading.gif" alt=""></p><p>在第 1 步，右侧的 goroutine 正在从通道接收一个值。<br>在第 2 步，右侧的这个 goroutine独立完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道里。<br>在第 3 步，左侧的goroutine 还在向通道发送新值，而右侧的 goroutine 正在从通道接收另外一个值。这个步骤里的两个操作既不是同步的，也不会互相阻塞。<br>最后，在第 4 步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</p><p><em>使用示例</em></p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/4/22 - 3:15 下午package mainimport (    &quot;fmt&quot;    &quot;sync&quot;)var wg sync.WaitGroup//go语言的channel 通道//go语言使用goroutine执行多个task任务//操作一个map或者其他变量或者内存时会发生数据竞争//使用go里面使用channel来解决并发并行来解决func main() {    //channel类型 相当于一个队列 first in -&gt; first out 先进先出原则    //定义一个channel类型 channel是一个引用类型 需要开辟空间    var ch chan int    fmt.Println(ch == nil) //true    //初始化一个无缓冲区的通道    ch = make(chan int)    wg.Add(1)    go func (){        defer wg.Done()        x := &lt;- ch        fmt.Println(x)    }()    ch &lt;- 2048 //会卡死main的主goroutine从而不能让程序进行执行    fmt.Println(ch) //无缓冲区的channel不能放入值    fmt.Println(ch == nil) //false    //初始化一个带缓冲区的通道    bufChan := make(chan int,8)    fmt.Println(cap(bufChan)) //8 CAP可以换取通道缓冲区大小    //发送值 使用这个&quot;&lt;-符号&quot; 获取也一样    bufChan &lt;- 1024    num := &lt;-bufChan    fmt.Println(bufChan)    fmt.Println(num)    wg.Wait()}</code></pre><blockquote><p>上面部分内容转载于链接：<a href="https://www.jianshu.com/p/e611d30feb9d" target="_blank" rel="noopener">https://www.jianshu.com/p/e611d30feb9d</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>goroutine</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go之goroutine浅入了解</title>
    <link href="/2020/04/22/Go%E4%B9%8Bgoroutine%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/04/22/Go%E4%B9%8Bgoroutine%E6%B5%85%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么goroutine"><a href="#1-什么goroutine" class="headerlink" title="1.什么goroutine?"></a>1.什么goroutine?</h1><p>goroutine是Go并行设计的核心。goroutine说到底其实就是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。<br>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p><p>Goroutine是建立在线程之上的轻量级的抽象。它允许我们以非常低的代价在同一个地址空间中并行地执行多个函数或者方法。相比于线程，它的创建和销毁的代价要小很多，并且它的调度是独立于线程的。在golang中创建一个goroutine非常简单，使用“go”关键字即可：</p><pre><code class="go">// Copyright (c) 2020 HigKer// Open Source: MIT License// Author: SDing &lt;deen.job@qq.com&gt;// Date: 2020/4/21 - 6:09 下午package mainimport (    &quot;fmt&quot;    &quot;math/rand&quot;    &quot;sync&quot;    &quot;time&quot;)var (    //这个是go里面用来配置goroutine使用的    //只能操作指针 因为他是一个struct 值类型！！！    wg sync.WaitGroup    //存放我们for的数字方便观察    sls []int)//go语言中的多个goroutine//WaitGroupfunc main() {    fmt.Println(&quot;goroutine begin:&quot;, sls)    for i := 0; i &lt;= 10; i++ {        // fatal error: all goroutines are asleep - deadlock!        //注意这里加的1不是i如果是i的话每次都是加的不一样然后出现👆的异常！！！        wg.Add(1)        go task(i)    }    fmt.Println(&quot;InService:&quot;, sls)    wg.Wait()    fmt.Println(&quot;End Over:&quot;, sls)}// fatal error: all goroutines are asleep - deadlock!func task(num int) {    defer func() {        wg.Done()    }()    //随机休眠几毫秒    time.Sleep(duration())    //将for循环的i存入到切片中我们等下好观察,    //打印控制台太慢了回漏掉    sls = append(sls, num) //不安全}//生成一个随机的等待时间 = 毫秒func duration() time.Duration {    rand.Seed(time.Now().UnixNano())    return time.Millisecond * time.Duration(rand.Intn(3000))}</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code class="shell">goroutine begin: []InService: []End Over: [4 10 9 8 6 1 0 3 2]</code></pre><blockquote><p>会出现一个问题多次运行你会发现有时候结果的slice会少一个数,这是因为，和线程一样，golang的主函数（其实也跑在一个goroutine中）并不会等待其它goroutine结束。如果主goroutine结束了，所有其它goroutine都将结束,所有后面我们就会将到go的channel来解决问题~数据竞争和数据共享,多个goroutine之间的通讯问题。</p></blockquote><h3 id="Goroutine与线程的区别"><a href="#Goroutine与线程的区别" class="headerlink" title="Goroutine与线程的区别"></a>Goroutine与线程的区别</h3><p>许多人认为goroutine比线程运行得更快，这是一个误解。Goroutine并不会更快，它只是增加了更多的并发性。当一个goroutine被阻塞（比如等待IO），golang的scheduler会调度其它可以执行的goroutine运行。与线程相比，它有以下几个优点：</p><h3 id="内存消耗更少："><a href="#内存消耗更少：" class="headerlink" title="内存消耗更少："></a>内存消耗更少：</h3><p>Goroutine所需要的内存通常只有2kb，而线程则需要1Mb（500倍）。<br>内存消耗更少：</p><h3 id="创建与销毁的开销更小"><a href="#创建与销毁的开销更小" class="headerlink" title="创建与销毁的开销更小"></a>创建与销毁的开销更小</h3><p>由于线程创建时需要向操作系统申请资源，并且在销毁时将资源归还，因此它的创建和销毁的开销比较大。相比之下，goroutine的创建和销毁是由go语言在运行时自己管理的，因此开销更低。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2mjdldsfj30hs0a5q3h.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="切换开销更小"><a href="#切换开销更小" class="headerlink" title="切换开销更小"></a>切换开销更小</h3><p>这是goroutine于线程的主要区别，也是golang能够实现高并发的主要原因。线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，就会被其它可执行的线程抢占。在线程切换的过程中需要保存/恢复所有的寄存器信息，比如16个通用寄存器，PC（Program Counter），SP（Stack Pointer），段寄存器等等。</p><p>而goroutine的调度是协同式的，它不会直接地与操作系统内核打交道。当goroutine进行切换的时候，之后很少量的寄存器需要保存和恢复（PC和SP）。因此gouroutine的切换效率更高。</p><h3 id="Goroutine的调度"><a href="#Goroutine的调度" class="headerlink" title="Goroutine的调度"></a>Goroutine的调度</h3><p>真如前面提到的，goroutine的调度方式是协同式的。在协同式调度中，没有时间片的概念。为了并行执行goroutine，调度器会在以下几个时间点对其进行切换：</p><h3 id="Channel接受或者发送会造成阻塞的消息"><a href="#Channel接受或者发送会造成阻塞的消息" class="headerlink" title="Channel接受或者发送会造成阻塞的消息"></a>Channel接受或者发送会造成阻塞的消息</h3><p>当一个新的goroutine被创建时<br>可以造成阻塞的系统调用，如文件和网络操作<br>垃圾回收<br>下面让我们来看一下调度器具体是如何工作的。Golang调度器中有三个概念</p><ul><li>Processor（P）</li><li>OSThread（M）</li><li>Goroutines（G）</li></ul><p>在一个Go程序中，可用的线程数是通过GOMAXPROCS来设置的，默认值是可用的CPU核数。我们可以用runtime包动态改变这个值。OSThread调度在processor上，goroutines调度在OSThreads上<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2ml5ze1wj30hs08at98.jpg" srcset="/img/loading.gif" alt=""><br>Golang的调度器可以利用多processor资源，在任意时刻，M个goroutine需要被调度到N个OS threads上，同时这些threads运行在至多GOMAXPROCS个processor上（N &lt;= GOMAXPROCS）。Go scheduler将可运行的goroutines分配到多个运行在一个或多个processor上的OS threads上。</p><p>每个processor有一个本地goroutine队列。同时有一个全局的goroutine队列。每个OSThread都会被分配给一个processor。最多只能有GOMAXPROCS个processor，每个processor同时只能执行一个OSThread。Scheculer可以根据需要创建OSThread。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge2mlz0si1j30hs08j74l.jpg" srcset="/img/loading.gif" alt=""><br>在每一轮调度中，scheduler找到一个可以运行的goroutine并执行直到其被阻塞,由此可见，操作系统的一个线程下可以并发执行上千个goroutine，每个goroutine所占用的资源和切换开销都很小，因此，goroutine是golang适合高并发场景的重要原因。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>golang</tag>
      
      <tag>goroutine</tag>
      
      <tag>channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac上配置Golang开发环境</title>
    <link href="/2020/03/13/Mac%E4%B8%8A%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/03/13/Mac%E4%B8%8A%E9%85%8D%E7%BD%AEGolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/13/JYRMzrxeKlLNp26.jpg" srcset="/img/loading.gif" alt="Golang"></p><blockquote><p><strong>📝本篇文章记录我本人在Mac上配置Go开发环境的笔记📒</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://github.com/golang/go" target="_blank" rel="noopener">Go Source Code</a></li><li>Go是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 罗伯特·格瑞史莫，罗勃·派克及肯·汤普逊于2007年9月开始设计Go，稍后Ian Lance Taylor、Russ Cox加入项目。Go是基于Inferno操作系统所开发的。</li><li>Go的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行计算模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，[2]，但它也具有pipeline模型的特征，比如通道传输。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。与C++相比，Go并不包括如枚举、异常处理、继承、泛型、断言、虚函数等功能，但增加了 切片(Slice) 型、并发、管道、垃圾回收功能、接口等特性的语言级支持[2]。Go 2.0版本将支持泛型[7]，对于断言的存在，则持负面态度，同时也为自己不提供类型继承来辩护。不同于Java，Go原生提供了关联数组（也称为哈希表（Hashes）或字典（Dictionaries）），就像字符串类型一样。</li></ul><h2 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h2><ul><li><a href="https://go.dev/" target="_blank" rel="noopener">Go Dev</a></li><li>浏览器🔛打开上面👆链接下载官方安装包<br><img src="https://i.loli.net/2020/03/13/XosNZdnTVtr3auA.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-13_15-54-37.jpg"></li><li>下载的时候根据自己系统版本下载对应的安装包</li><li>下载完成之后双击安装包即可安装</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>我本人Mac是使用的<code>iTerm2 + Oh My Zsh + zsh</code>所以我只需要编辑我的<code>~/.zshrc</code>文件📃即可.</p><ul><li>通过vscode打开<pre><code class="bash">code ~/.zshrc</code></pre></li><li>在文件最后添加修改配置<pre><code class="bash">##go语言环境配置 ##go 语言安装主根目录export GOROOT=/usr/local/go#GOPATH是自己的go项目路径，自定义设置export GOPATH=/Users/ding/Documents/GO_CODE_DEV# 启用 Go Modules 功能export GO111MODULE=on# 配置 GOPROXY 环境变量 &amp; 国内网络环境大家都知道不多说export GOPROXY=https://goproxy.io,directexport PATH=$PATH:$GOBIN:$GOPATH/bin:GO111MODULE:GOPROXY</code></pre></li><li>然后使用<code>source ~/.zshrc</code>文件</li><li>在terminal里面输入<code>go env</code>即可查看环境<br><img src="https://i.loli.net/2020/03/13/3hrCzjTS5D4MlKJ.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-13_16-07-43.jpg"></li></ul><h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><p>我个人使用vscode比较多一点,Goland在开发大型项目才使用<br><strong>VS Code官方下载地址：<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a></strong><br>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。双击下载好的安装文件，双击安装即可。</p><ul><li><h4 id="安装Go语言开发工具包"><a href="#安装Go语言开发工具包" class="headerlink" title="安装Go语言开发工具包"></a>安装Go语言开发工具包</h4><p>在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。<br>Windows平台按下Ctrl+Shift+P，Mac平台按Command+Shift+P，这个时候VS Code界面会弹出一个输入框，如下图：<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535662106193.jpg" srcset="/img/loading.gif" alt="GO"><br>我们在这个输入框中输入<code>&gt;go:install</code>，下面会自动搜索相关命令，我们选择<code>Go:Install/Update Tools</code>这个命令<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535659707162.jpg" srcset="/img/loading.gif" alt="GOINSTALL"><br>选中并会回车执行该命令（或者使用鼠标点击该命令）<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535665573387.jpg" srcset="/img/loading.gif" alt="golang"></p></li><li><h4 id="配置代码片段快捷键"><a href="#配置代码片段快捷键" class="headerlink" title="配置代码片段快捷键"></a>配置代码片段快捷键</h4><p>还是按Ctrl/Command+Shift+P,按下图输入<code>&gt;snippets</code>，选择命令并执行<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535687503862.jpg" srcset="/img/loading.gif" alt="GO"><br>配置<code>snippets</code>代码片段模本<br><img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/15535688890224.jpg" srcset="/img/loading.gif" alt="GO SNIPPETS"><br>大家可以简单看下上面的注释，介绍了主要用法：</p><pre><code class="json">    “这里放个名字”:{      &quot;prefix&quot;: &quot;这个是快捷键&quot;,      &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,      &quot;description&quot;: &quot;这里放提示信息的描述&quot;    }</code></pre><p> 其中<code>$0</code>表示最终光标提留的位置。举个例子，我这里创建了两个快捷方式，一个是输入<code>pln</code>就会在编辑器中插入<code>fmt.Println()</code>代码；输入<code>plf</code>，就会插入<code>fmt.Printf(&quot;&quot;)</code>代码。</p><pre><code class="json">  {    &quot;println&quot;:{      &quot;prefix&quot;: &quot;pln&quot;,      &quot;body&quot;:&quot;fmt.Println($0)&quot;,      &quot;description&quot;: &quot;println&quot;    },    &quot;printf&quot;:{      &quot;prefix&quot;: &quot;plf&quot;,      &quot;body&quot;: &quot;fmt.Printf(\&quot;$0\&quot;)&quot;,      &quot;description&quot;: &quot;printf&quot;    }  }</code></pre><p>添加如上配置后，保存。 我们打开一个go文件，测试一下效果：<br> <img src="https://www.liwenzhou.com/images/Go/00_config_VSCode/demo1.gif" srcset="/img/loading.gif" alt="fmt.println"></p></li></ul><p><strong>好了配置完成,开始愉快的coding吧👨‍💻‍Good luck~😜</strong>   </p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Golang</tag>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo集成gitalk评论组件</title>
    <link href="/2020/03/08/Hexo%E9%9B%86%E6%88%90gitalk%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/03/08/Hexo%E9%9B%86%E6%88%90gitalk%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/BayMRX/Blog_source@master/img/hexo.jpg" srcset="/img/loading.gif" alt="hexo"></p><blockquote><p><strong>一个基于 Github Issue 和 Preact 开发的评论插件,下面我们就来使用gitalk来实现hexo的评论功能。</strong></p></blockquote><h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk开源地址</a></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>使用 GitHub 登录</li><li>支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]</li><li>支持个人或组织</li><li>无干扰模式（设置 distractionFreeMode 为 true 开启）</li><li>快捷键提交评论 （cmd|ctrl + enter）</li></ul><p><a href="https://github.com/gitalk/gitalk/blob/master/readme.md" target="_blank" rel="noopener">Readme</a><br><a href="https://gitalk.github.io" target="_blank" rel="noopener">在线示例</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>两种方式</p><ul><li>直接引入</li></ul><pre><code class="html">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;  &lt;!-- or --&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;  &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>npm 安装</li></ul><pre><code class="sh">npm i --save gitalk</code></pre><pre><code class="js">import &#39;gitalk/dist/gitalk.css&#39;import Gitalk from &#39;gitalk&#39;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加一个容器：</p><pre><code class="html">&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</code></pre><p>用下面的 Javascript 代码来生成 gitalk 插件：</p><pre><code class="js">var gitalk = new Gitalk({  clientID: &#39;GitHub Application Client ID&#39;,  clientSecret: &#39;GitHub Application Client Secret&#39;,  repo: &#39;GitHub repo&#39;,  owner: &#39;GitHub repo owner&#39;,  admin: [&#39;GitHub repo owner and collaborators, only these guys can initialize github issues&#39;],  id: location.pathname,      // Ensure uniqueness and length less than 50  distractionFreeMode: false  // Facebook-like distraction free mode})gitalk.render(&#39;gitalk-container&#39;)</code></pre><p>需要 <strong>GitHub Application</strong>，如果没有 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击这里申请</a>，<code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p><p><strong>⚠️更多帮助在官方文档,可以在官方链接里查询。</strong></p><h2 id="设置GitHub"><a href="#设置GitHub" class="headerlink" title="设置GitHub"></a>设置GitHub</h2><ul><li>在个人设置里面创建一个Application<br><img src="https://i.loli.net/2020/03/08/fKqE9JHALBXMnN7.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-07_12-46-47.jpg"></li><li>然后我们需要的ClientID和Token<br><img src="https://i.loli.net/2020/03/08/vAx7wkRFhsNyqtX.jpg" srcset="/img/loading.gif" alt="clientId"></li><li>创建一个存放lssue仓库<br><img src="https://i.loli.net/2020/03/08/jeBmlY2RD6Fi35E.jpg" srcset="/img/loading.gif" alt="Xnip2020-03-07_13-00-14.jpg"><h2 id="在Hexo里使用"><a href="#在Hexo里使用" class="headerlink" title="在Hexo里使用"></a>在Hexo里使用</h2><blockquote><p>这里我使用的主题里面已经集成了gitalk,所有我们直接修改配置文件就可以了。根据个人配置方法不同查询各种文档！！！</p></blockquote></li></ul><p>下面是我的配置文件📃</p><pre><code class="yaml"># Gitalk# You can get yout ClientID and ClientSecret from https://github.com/settings/applications/new# More info available at https://github.com/gitalk/gitalk#optionsgitalk:  clientID: 这里填写你之前application的clientID # GitHub Application Client ID  clientSecret: 之前申请的 # GitHub Application Client Secret  repo: ibyte.me # The repo to store comments  owner: deencode # GitHub repository owner. Can be personal user or organization.  admin: deencode # GitHub repo owner and collaborators, only these guys can initialize github issues, should be like &quot;[&#39;admin&#39;]&quot; or &quot;[&#39;admin1&#39;,&#39;admin2&#39;]&quot;  id: location.pathname # The unique id of the page. Length must less than 50.  language: zh-CN # Localization language key, en, zh-CN and zh-TW are currently available.  labels: &quot;[&#39;Gitalk&#39;]&quot; # GitHub issue labels.  perPage: 15 # Pagination size, with maximum 100.  pagerDirection: last # Comment sorting direction, available values are last and first.  distractionFreeMode: false # Facebook-like distraction free mode.  createIssueManually: true # By default, Gitalk will create a corresponding github issue for your every single page automatically when the logined user is belong to the admin users. You can create it manually by setting this option to true.</code></pre><p><strong>配置方法不同有所差异!!根据自己使用的插件查询官方文档进行的配置！！！Good Luck😜</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>gitalk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo搭建Blog</title>
    <link href="/2020/03/06/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BABlog/"/>
    <url>/2020/03/06/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BABlog/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/06/cOUwFstAaTeyGQk.jpg" srcset="/img/loading.gif" alt="Hexo&amp;GithubPage.jpg"></p><h3 id="1-相关网站"><a href="#1-相关网站" class="headerlink" title="1. 相关网站"></a>1. 相关网站</h3><ul><li>[Github]: <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></li><li>[Hexo]: <a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li><li>[Hexo Theme]: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>[Hexo Docs]: <a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li></ul><h3 id="2-创建Github-Key"><a href="#2-创建Github-Key" class="headerlink" title="2. 创建Github Key"></a>2. 创建Github Key</h3><p>设置你的用户名称与邮件地址，如果是第一次使用git的话</p><pre><code class="bash">$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com</code></pre><p>使用ssh-keygen生成私钥和公钥<br>命令如下：</p><pre><code class="bash">$ ssh-keygen -t rsa</code></pre><p>然后到你GitHub 设置里面添加你刚才生成的xx.pub的内容到Key里面.</p><pre><code class="bash">$ ssh -T git@github.com</code></pre><p>登录Github，点击头像下的settings，添加ssh,新建一个new ssh key，将id_rsa.pub文件里的内容复制上去。</p><p>输入ssh -T <a href="mailto:git@github.com">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了。</p><p>这里你可以去创建一个public的仓库来存储等下Hexo相关的文件.</p><h3 id="3-安装NPM和Hexo"><a href="#3-安装NPM和Hexo" class="headerlink" title="3. 安装NPM和Hexo"></a>3. 安装NPM和Hexo</h3><ul><li>[NodeJS网站]: <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></li></ul><p>通过上面的网站下载对应的系统版本的NodeJS安装包.</p><ol><li><strong>设置NPM源到淘宝源</strong></li></ol><pre><code class="bash">   npm config set registry https://registry.npmjs.org/</code></pre><ol start="2"><li><p><strong>NPM安装HexoCli</strong></p><p>输入npm install hexo -g，开始安装Hexo</p></li></ol><pre><code class="bash">   npm install hexo -g</code></pre><ol start="3"><li><p><strong>初始化Hexo</strong></p><p>输入hexo -v，检查hexo是否安装成功</p><p>输入hexo init，初始化该文件夹（有点漫长的等待…）看到后面的“Start blogging with Hexo！”就说明初始化好了</p><p>输入npm install，安装所需要的组件</p></li></ol><pre><code class="bash">$ hexo -v$ hexo init$ hexo install        </code></pre><h3 id="4-配置config-yml文件"><a href="#4-配置config-yml文件" class="headerlink" title="4.配置config.yml文件"></a>4.配置config.yml文件</h3><p><strong>PS:这里根据自己需要自己配置，你可以去查询官方文档！！</strong></p><pre><code class="bash">deploy:  type: git  repo: git@github.com:Deencode/ibyte.me.git  branch: master</code></pre><h3 id="5-生成静态文件-amp-上传到GitHub仓库"><a href="#5-生成静态文件-amp-上传到GitHub仓库" class="headerlink" title="5.生成静态文件&amp;上传到GitHub仓库"></a>5.生成静态文件&amp;上传到GitHub仓库</h3><p><strong>🎉: 到了这一步就差不多了，运行下面命令就可以生成文件了.</strong></p><pre><code class="bash">#生成文件$ hexo generate#监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件#在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。$ hexo generate --watch# 本地运行$ hexo server#您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。$ hexo deploy</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
